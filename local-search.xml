<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JAVA8新特性:接口也可以写实现方法</title>
    <link href="/2022/06/02/JAVA8%E6%96%B0%E7%89%B9%E6%80%A7-%E6%8E%A5%E5%8F%A3%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%86%99%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <url>/2022/06/02/JAVA8%E6%96%B0%E7%89%B9%E6%80%A7-%E6%8E%A5%E5%8F%A3%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%86%99%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在日常开发中可能很多人对 <strong>JAVA8</strong> 的一些新特性不太关注，</p><p>有一个新特性看似不起眼，一旦用到了则会觉得非常的方便。</p><p>很多人都觉得<strong>接口里面只能写抽象方法，不能写实现方法;</strong></p><p>实际上在 JAVA8 更新后，接口就可以添加默认方法和静态方法：默认方法用default修饰符修饰，会被其他接口继承；而静态方法使用static修饰符修饰。</p><p>非常典型的就是 <code>java.util.Map</code>，有兴趣的可以去瞧一瞧。</p><h2 id="为什么要有接口默认方法？"><a href="#为什么要有接口默认方法？" class="headerlink" title="为什么要有接口默认方法？"></a>为什么要有接口默认方法？</h2><p>举一个很现实的例子：</p><p>我们的接口老早就写好了，后面因为各种业务问题，避免不了要修改接口。</p><p>在 Java 8 之前，比如要在一个接口中添加一个抽象方法，那所有的接口实现类都要去实现这个方法，不然就会编译错误，而某些实现类根本就不需要实现这个方法也被迫要写一个空实现，改动会非常大。</p><p>所以，接口默认方法就是为了解决这个问题，只要在一个接口添加了一个默认方法，所有的实现类就自动继承，不需要改动任何实现类，也不会影响业务，爽歪歪。</p><p>另外，接口默认方法可以被接口实现类重写。</p><h2 id="为什么要有接口静态方法？"><a href="#为什么要有接口静态方法？" class="headerlink" title="为什么要有接口静态方法？"></a>为什么要有接口静态方法？</h2><p>接口静态方法和默认方法类似，只是接口静态方法不可以被接口实现类重写。</p><p>接口静态方法只可以直接通过静态方法所在的 <code>接口名</code>.<code>静态方法名</code> 来调用。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>在接口多继承的情况下，被继承的接口如果存在相同的默认方法，是会引起编译报错的，如果在继承接口类中不重写此默认方法是会报错的；</p><p>如果需要调用父类的方法可以通过 被继承类的类名.super.默认方法名 的形式调用父类默认方法；</p><p>有一种情况下例外：就是多继承的接口有相同的默认方法，也就是其中一个接口重写了父类的默认方法，这种情况下不需要重写默认方法；</p><p>默认方法与接口抽象方法定义相同：默认方法会优先于接口抽象方法,接口定义的方法会被忽略。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java List排序的几种实现</title>
    <link href="/2022/06/02/Java-List%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/06/02/Java-List%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>排序对象类</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方式一：实现Comparable接口"><a href="#方式一：实现Comparable接口" class="headerlink" title="方式一：实现Comparable接口"></a>方式一：实现Comparable接口</h2><p>修改Student类实现Comparable接口 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Student</span>&gt;</span>&#123;<br><br>......<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 需要实现的方法，实现升序排序，降序请反写</span><br><span class="hljs-comment">     * this表示当前的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o 比较时传入的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Student o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age - o.age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关于compareTo方法</strong></p><ul><li>返回值&gt;0：表示当前对象比传入对象大</li><li>返回值=0：表示当前对象和传入对象一样大</li><li>返回值&lt;0：表示当前对象比传入对象小</li></ul><br><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//数据准备</span><br>        List&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">1</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小红&quot;</span>,<span class="hljs-number">4</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小刚&quot;</span>,<span class="hljs-number">3</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小鸡&quot;</span>,<span class="hljs-number">5</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小狗&quot;</span>,<span class="hljs-number">2</span>));<br>        <span class="hljs-comment">//使用Collections集合工具类进行排序</span><br>        Collections.sort(list);<br>        <span class="hljs-keyword">for</span> (Student student : list) &#123;<br>            System.out.println(student);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方式二：使用Comparator接口"><a href="#方式二：使用Comparator接口" class="headerlink" title="方式二：使用Comparator接口"></a>方式二：使用Comparator接口</h2><p>使用方式一我们必须在Student类上面进行修改，这显然不是最好的办法，如果我们不想按年龄排序，想要按照姓名排序，或者我们有一个方法需要按照年龄，另一个方法需要按照姓名，那么重写compareTo方法显然就没法完成我们的目标了，Collections的重载sort方法可以允许我们在排序对象外部自定义一个比较器（Comparator接口的实现类），因为我们仅需要实现compare（）方法，没必要在定义一个类，我们直接使用匿名内部类的方式。</p><p>此时的Student类我们不用进行任何改写，和最原始的一样即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//数据准备</span><br>        List&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">1</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小红&quot;</span>,<span class="hljs-number">4</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小刚&quot;</span>,<span class="hljs-number">3</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小鸡&quot;</span>,<span class="hljs-number">5</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小狗&quot;</span>,<span class="hljs-number">2</span>));<br>        <br>        <span class="hljs-comment">//使用Collections集合工具类进行排序</span><br>        Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br>                <span class="hljs-comment">//升序排序，降序反写</span><br>                <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (Student student : list) &#123;<br>            System.out.println(student);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了Collections类的sort方法，我们还可以使用List类的sort方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//数据准备</span><br>        List&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">1</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小红&quot;</span>,<span class="hljs-number">4</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小刚&quot;</span>,<span class="hljs-number">3</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小鸡&quot;</span>,<span class="hljs-number">5</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小狗&quot;</span>,<span class="hljs-number">2</span>));<br><br><span class="hljs-comment">//使用List类的sort方法，都是实现Comparator接口</span><br>        list.sort(<span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (Student student : list) &#123;<br>            System.out.println(student);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="方式三：Lambda表达式"><a href="#方式三：Lambda表达式" class="headerlink" title="方式三：Lambda表达式"></a>方式三：Lambda表达式</h2><p>方式二相比，只改变了一行代码<br>将</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java">Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br>                <span class="hljs-comment">//升序排序，降序反写</span><br>                <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();<br>            &#125;<br><br>        &#125;);<br></code></pre></td></tr></table></figure><p>变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(list, (o1, o2) -&gt; o1.getAge() - o2.getAge());<br></code></pre></td></tr></table></figure><h2 id="方式四：使用Comparator接口的静态方法"><a href="#方式四：使用Comparator接口的静态方法" class="headerlink" title="方式四：使用Comparator接口的静态方法"></a>方式四：使用Comparator接口的静态方法</h2><p>上文方式三</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(list, (o1, o2) -&gt; o1.getAge() - o2.getAge());<br></code></pre></td></tr></table></figure><p>可以变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(list, Comparator.comparingInt(Student::getAge));<br></code></pre></td></tr></table></figure><p>ps: 为什么接口可以有自己的实现方法呢，可以看这篇文章 <a href="/2022/06/02/JAVA8%E6%96%B0%E7%89%B9%E6%80%A7-%E6%8E%A5%E5%8F%A3%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%86%99%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/">JAVA8新特性-接口也可以写实现方法</a></p><h2 id="方式五：使用Stream流"><a href="#方式五：使用Stream流" class="headerlink" title="方式五：使用Stream流"></a>方式五：使用Stream流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Student&gt; students = list.stream().<br>                sorted((Comparator.comparingInt(Student::getAge)))<br>                .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h2 id="PS：数组（Array）的排序"><a href="#PS：数组（Array）的排序" class="headerlink" title="PS：数组（Array）的排序"></a>PS：数组（Array）的排序</h2><p>使用 Arrays.sort 方法</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用HTTPS连接远程仓库时修改账号密码的方法</title>
    <link href="/2022/05/17/Git%E4%BD%BF%E7%94%A8HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%97%B6%E4%BF%AE%E6%94%B9%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/17/Git%E4%BD%BF%E7%94%A8HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%97%B6%E4%BF%AE%E6%94%B9%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><p>我们平时连接远程仓库（如Github，Gitee）时，通常使用2种方式，一种是SSH，另一种是HTTPS。使用SSH方式的话需要配置SSH公钥，过程稍微有点小麻烦，所以我更偏向于使用HTTPS方式。但是使用HTTPS方式有一个缺点，就是当你修改网站的密码之后，再推/拉代码的时候会失败，需要我们手动修改一下电脑本地存储的密码。下面记录一下修改方法，以防忘记。</p><h1 id="1、打开凭据管理器"><a href="#1、打开凭据管理器" class="headerlink" title="1、打开凭据管理器"></a>1、打开凭据管理器</h1><p>第一种方法，点击左下角的搜索，输入凭据管理器，然后打开</p><p><img src="/2022/05/17/Git%E4%BD%BF%E7%94%A8HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%97%B6%E4%BF%AE%E6%94%B9%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/image-20220517005412486.png" alt="方法一"></p><br><p>第二种方法，打开控制面板，找到凭据管理器并打开</p><p><img src="/2022/05/17/Git%E4%BD%BF%E7%94%A8HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%97%B6%E4%BF%AE%E6%94%B9%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/image-20220517005720392.png" alt="方法二"></p><h1 id="2、修改账号密码"><a href="#2、修改账号密码" class="headerlink" title="2、修改账号密码"></a>2、修改账号密码</h1><p>打开凭据管理器之后，选择<code>Windows凭据</code></p><p><img src="/2022/05/17/Git%E4%BD%BF%E7%94%A8HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%97%B6%E4%BF%AE%E6%94%B9%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/image-20220517010005190.png" alt="选择Windows凭据"></p><br><p>然后就可以修改某个远程仓库的密码啦</p><p><img src="/2022/05/17/Git%E4%BD%BF%E7%94%A8HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%97%B6%E4%BF%AE%E6%94%B9%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/image-20220517010319503.png" alt="image-20220517010319503"></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在宝塔面板搭建自己的邮件服务器</title>
    <link href="/2022/04/04/%E5%9C%A8%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/04/04/%E5%9C%A8%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><p>既然现在有了自己的域名和服务器，那为何不搭建一个以自己域名为后缀的邮箱玩玩呢😎</p><p>有了自己的邮件服务器，就有了无限个账号，以后用来注册一些网站还是很方便的。</p><p>下面说一下搭建步骤</p><h1 id="1、添加DNS解析"><a href="#1、添加DNS解析" class="headerlink" title="1、添加DNS解析"></a>1、添加DNS解析</h1><p>首先配置DNS解析，这里我用的是cloudflare，其他dns服务商同理。</p><p>先添加一条A记录，名称填<code>mail</code>，地址填服务器ipv4地址，不要勾代理，保存。</p><p>（PS：我的域名没有备案，所以解析到国内的服务器也不能访问自己的网站，但是用来做域名邮箱倒是可以，应该是因为端口不同吧）</p><p><img src="/2022/04/04/%E5%9C%A8%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220404174338376.png" alt="A记录"></p><p>再添加一条MX记录，名称填<code>@</code>，邮件服务器填 <code>mail.自己的域名</code>，优先级这里我随便填个10</p><p><img src="/2022/04/04/%E5%9C%A8%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220404175028193.png" alt="MX记录"></p><h1 id="2、安装宝塔邮局管理器"><a href="#2、安装宝塔邮局管理器" class="headerlink" title="2、安装宝塔邮局管理器"></a>2、安装宝塔邮局管理器</h1><p>在软件商店里直接搜索并安装就可以了，非常简单</p><p><img src="/2022/04/04/%E5%9C%A8%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220404174143935.png" alt="安装邮局"></p><p>装完之后打开邮局管理器，点击添加域名，然后填上自己的域名和A记录，提交</p><p><img src="/2022/04/04/%E5%9C%A8%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220404175442322.png" alt="添加邮箱域名"></p><p>提交成功后，下图红框这里应该是打红叉的，我没有截到那个图，这里就放一张最终的图。点击红叉，根据里面的提示在cloudflare再加3条DNS记录就好了</p><p><img src="/2022/04/04/%E5%9C%A8%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220404175827399.png" alt="添加成功"></p><p><img src="/2022/04/04/%E5%9C%A8%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220404180713967.png" alt="DNS记录"></p><p>添加完后刷新域名记录，就变全绿了，如果没有变绿就等一会再试。</p><h1 id="3、添加用户"><a href="#3、添加用户" class="headerlink" title="3、添加用户"></a>3、添加用户</h1><p>在邮箱域名的右侧点击用户管理，添加一个用户</p><p><img src="/2022/04/04/%E5%9C%A8%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220404181141510.png" alt="用户管理"></p><p>上图有IMAP/POP3/SMTP服务的地址和端口，如果想在其他邮箱客户端登录我们的邮箱，需要在防火墙放行这3个端口。</p><p><img src="/2022/04/04/%E5%9C%A8%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220404181017146.png" alt="防火墙"></p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>邮件</tag>
      
      <tag>宝塔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java:字节流和字符流（输入流和输出流）</title>
    <link href="/2022/04/02/Java-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%88%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%89/"/>
    <url>/2022/04/02/Java-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%88%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1、什么是流"><a href="#1、什么是流" class="headerlink" title="1、什么是流"></a>1、什么是流</h1><ul><li>流是个抽象的概念，是对输入输出设备的抽象，输入流可以看作一个输入通道，输出流可以看作一个输出通道。</li><li>输入流是相对程序而言的，外部传入数据给程序需要借助输入流。</li><li>输出流是相对程序而言的，程序把数据传输到外部需要借助输出流。</li></ul><h2 id="1-1-什么是字节流？"><a href="#1-1-什么是字节流？" class="headerlink" title="1.1 什么是字节流？"></a>1.1 什么是字节流？</h2><p>字节流–传输过程中，传输数据的最基本单位是<font color="red"><strong>字节</strong></font>的流（也就是由0/1组成的流）。</p><h2 id="1-2-什么是字符流？"><a href="#1-2-什么是字符流？" class="headerlink" title="1.2 什么是字符流？"></a>1.2 什么是字符流？</h2><p>字符流–传输过程中，传输数据的最基本单位是<font color="red"><strong>字符</strong></font>的流（也就是由数字/字母/符号组成的流）。</p><h2 id="1-3-字节和字符的关系"><a href="#1-3-字节和字符的关系" class="headerlink" title="1.3 字节和字符的关系"></a>1.3 字节和字符的关系</h2><p>字符编码方式不同，有时候一个字符使用的字节数也不一样，比如ASCII方式编码的字符，占一个字节（1B，8bit）；而UTF-8方式编码的字符，一个英文字符需要一个字节，一个中文需要三个字节。</p><p>字节数据是二进制形式的，要转成我们能识别的正常字符，需要选择正确的编码方式。我们生活中遇到的乱码问题就是字节数据没有选择正确的编码方式来显示成字符。</p><p>从本质上来讲，写数据（即输出）的时候，字节也好，字符也好，本质上都是没有标识符的，需要去指定编码方式。</p><p>但读数据的时候，如果我们需要去“看数据”，那么字节流的数据需要指定字符编码方式，这样我们才能看到我们能识别的字符；而字符流，因为已经选择好了字符编码方式，通常不需要再改了（除非定义的字符编码方式与数据原有的编码方式不一致！）</p><p>在传输方面上，由于计算机的传输本质都是字节，而一个字符由多个字节组成，转成字节之前先要去查表转成字节，所以传输时有时候会使用缓冲区。</p><h1 id="2、字节流"><a href="#2、字节流" class="headerlink" title="2、字节流"></a>2、字节流</h1><ul><li><p>字节流的类通常以stream结尾</p></li><li><p>InputStream、OutputStream</p><ul><li>处理字节流的抽象类</li><li>InputStream 是字节<font color="red"><strong>输入流</strong></font>的所有类的超类，一般我们使用它的子类，如FileInputStream等</li><li>OutputStream是字节<font color="red"><strong>输出流</strong></font>的所有类的超类，一般我们使用它的子类，如FileOutputStream等</li></ul></li></ul><h2 id="2-1-字节输入流"><a href="#2-1-字节输入流" class="headerlink" title="2.1 字节输入流"></a>2.1 字节输入流</h2><p>常用的字节输入流主要有：</p><ul><li>InputStream </li><li>FileInputStream</li><li>BufferedInputStream 【BufferedInputStream不是InputStream的直接实现子类，是FilterInputStream的子类】</li></ul><h3 id="2-1-1-他们的区别与用途"><a href="#2-1-1-他们的区别与用途" class="headerlink" title="2.1.1 他们的区别与用途"></a>2.1.1 他们的区别与用途</h3><ul><li><p>InputStream 是字节输入流的抽象基类，InputStream作为基类，给它的基类定义了几个通用的函数：</p><ul><li>read(byte[] b)：从流中读取b的长度个字节的数据存储到b中，返回结果是读取的字节个数（当再次读时，如果返回-1说明到了结尾，没有了数据）</li><li>read(byte[] b, int off, int len)：从流中从off的位置开始读取len个字节的数据存储到b中，返回结果是实际读取到的字节个数（当再次读时，如果返回-1说明到了结尾，没有了数据）</li><li>close()：关闭流，释放资源。</li></ul></li><li><p>FileInputStream 主要用来操作文件输入流，它除了可以使用基类定义的函数外，它还实现了基类的read()函数（无参的）：</p><ul><li>read(): 从流中读取1个字节的数据，返回结果是一个int，（如果编码是以一个字节一个字符的，可以尝试转成char，用来查看数据）。</li></ul></li><li><p>BufferedInputStream 带有缓冲的意思，普通的读是从硬盘里面读，而带有缓冲区之后，BufferedInputStream已经提前将数据封装到内存中，内存中操作数据要快，所以它的效率要要非缓冲的要高。它除了可以使用基类定义的函数外，它还实现了基类的read()函数（无参的）：</p><ul><li>read(): 从流中读取1个字节的数据，返回结果是一个int，（如果编码是以一个字节一个字符的，可以尝试转成char，用来查看数据）。</li></ul></li></ul><h3 id="2-1-2-使用"><a href="#2-1-2-使用" class="headerlink" title="2.1.2 使用"></a>2.1.2 使用</h3><ul><li><p>InputStream是抽象基类，所以它不可以创建对象，但它可以用来“接口化编程”，因为大部分子类的函数基类都有定义，所以利用基类来调用函数。</p></li><li><p>FileInputStream是用来读文件数据的流，所以它需要一个文件对象用来实例化，这个文件可以是一个File对象,也可以是文件名路径字符串.【这里文件不存在会抛错】</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:/a.txt&quot;</span>);  <span class="hljs-comment">//使用文件路径实例化</span><br><span class="hljs-comment">//            File file = new File(&quot;D:/a.txt&quot;);</span><br><span class="hljs-comment">//            FileInputStream fis2 = new FileInputStream(file); //使用File对象实例化</span><br>            <span class="hljs-keyword">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">int</span> len;<br>            <span class="hljs-keyword">while</span> ((len = fis.read(buff)) != -<span class="hljs-number">1</span>)&#123;<br>                System.out.println(<span class="hljs-keyword">new</span> String(buff, <span class="hljs-number">0</span>, len));<br>            &#125;<br>            fis.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;读取文件出错&quot;</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>BufferedInputStream是一种封装别的流以提高效率的流，所以它的初始化需要一个的InputStream流对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:/a.txt&quot;</span>);  <span class="hljs-comment">//使用文件路径实例化</span><br>            BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);  <span class="hljs-comment">//可用任意InputStream的对象实例化它</span><br>            <span class="hljs-keyword">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">int</span> len;<br>            <span class="hljs-keyword">while</span> ((len = bis.read(buff)) != -<span class="hljs-number">1</span>)&#123;<br>                System.out.println(<span class="hljs-keyword">new</span> String(buff, <span class="hljs-number">0</span>, len));<br>            &#125;<br>            bis.close();<br>            fis.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;读取文件出错&quot;</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-2-字节输出流"><a href="#2-2-字节输出流" class="headerlink" title="2.2 字节输出流"></a>2.2 字节输出流</h2><p>常用的字节输出流主要有：</p><ul><li>OutputStream</li><li>FileOutputStream</li><li>BufferedOutputStream 【BufferedOutputStream不是OutputStream的直接实现子类，是FilterOutputStream的子类】</li></ul><h3 id="2-2-1-他们的区别与用途"><a href="#2-2-1-他们的区别与用途" class="headerlink" title="2.2.1 他们的区别与用途"></a>2.2.1 他们的区别与用途</h3><ul><li><p>OutputStream是字节输出流的基类， OutputStream作为基类，给它的基类定义了几个通用的函数：</p><ul><li>write(byte[] b):  将b的长度个字节数据写到输出流中。</li></ul><ul><li>write(byte[] b,int off,int len):  从b的off位置开始，获取len个字节数据，写到输出流中。</li></ul><ul><li>flush():  刷新输出流，把数据马上写到输出流中。</li></ul><ul><li>close():  关闭流，释放系统资源。</li></ul></li></ul><ul><li><p>FileOutputStream是用于写文件的输出流，它除了可以使用基类定义的函数外,还实现了OutputStream的抽象函数write(int b):</p><ul><li>write(int b):  将b转成一个字节数据，写到输出流中。</li></ul></li><li><p>BufferedOutputStream像上面那个BufferedInputStream一样，都可以提高效率。它除了可以使用基类定义的函数外,它还实现了OutputStream的抽象函数write(int b):</p><ul><li>write(int b):  将b转成一个字节数据，写到输出流中。</li></ul></li></ul><h3 id="2-2-2-使用"><a href="#2-2-2-使用" class="headerlink" title="2.2.2 使用"></a>2.2.2 使用</h3><ul><li>OutputStream是抽象基类，所以它不能实例化，但它可以用于接口化编程。</li><li>FileOutputStream是用于写文件的输出流，所以它需要一个文件作为实例化参数，这个文件可以是File对象，也可以是文件路径字符串。【如果文件不存在，那么将自动创建。】【FileOutputStream实例化时可以给第二个参数，第二个参数是是否使用追加写入默认，为true时代表在原有文件内容后面追加写入数据，默认为false】</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:/b.txt&quot;</span>);<br>            fos.write(<span class="hljs-string">&quot;hello world&quot;</span>.getBytes());<br>            fos.close();<br><br>            FileOutputStream fos2 = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:/b.txt&quot;</span>, <span class="hljs-keyword">true</span>); <span class="hljs-comment">//true在原文件后面追加内容，false覆盖原文件</span><br>            fos2.write(<span class="hljs-string">&quot;你好世界&quot;</span>.getBytes());<br>            fos2.close();<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;写入文件出错&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>BufferedOutputStream需要一个输出流作为实例化参数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     <span class="hljs-keyword">try</span> &#123;<br>         FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:/b.txt&quot;</span>);<br>         BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);<br>         bos.write(<span class="hljs-string">&quot;hello world&quot;</span>.getBytes());<br>         bos.close();<br>         fos.close();<br>     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>         System.out.println(<span class="hljs-string">&quot;写入文件出错&quot;</span>);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="3、字符流"><a href="#3、字符流" class="headerlink" title="3、字符流"></a>3、字符流</h1><ul><li><p>字符流的类通常以reader和writer结尾</p></li><li><p>Reader、Writer</p><ul><li>处理字符流的抽象类</li><li>Reader 是<strong>字节流</strong>通向<strong>字符流</strong>的桥梁，它将字节流转换为字符流.</li><li>Writer 是<strong>字符流</strong>通向<strong>字节流</strong>的桥梁，它将字符流转换为字节流.</li></ul></li></ul><h2 id="3-1-字符输入流"><a href="#3-1-字符输入流" class="headerlink" title="3.1 字符输入流"></a>3.1 字符输入流</h2><p>常见的字符输入流有：</p><ul><li>Reader</li><li>InputStreamReader</li><li>FileReader</li><li>BufferedReader</li></ul><h3 id="3-1-1-他们的区别与用途"><a href="#3-1-1-他们的区别与用途" class="headerlink" title="3.1.1 他们的区别与用途"></a>3.1.1 他们的区别与用途</h3><ul><li>Reader 是字符输入流的抽象基类，它定义了以下几个函数：<ul><li>read() ：读取单个字符，返回结果是一个int，需要转成char;到达流的末尾时，返回-1</li><li>read(char[] cbuf) :  读取cbuf的长度个字符到cbuf中，返回结果是读取的字符数，到达流的末尾时，返回-1</li><li>close() ：关闭流，释放占用的系统资源。</li></ul></li><li>InputStreamReader 可以把InputStream中的字节数据流根据字符编码方式转成字符数据流。它除了可以使用基类定义的函数，它自己还实现了以下函数：<ul><li>read(char[] cbuf, int offset, int length) ：从offset位置开始，读取length个字符到cbuf中，返回结果是实际读取的字符数，到达流的末尾时，返回-1</li></ul></li><li>FileReader 可以把FileInputStream中的字节数据转成根据字符编码方式转成字符数据流。</li><li>BufferedReader 可以把字符输入流进行封装，将数据进行缓冲，提高读取效率。它除了可以使用基类定义的函数，它自己还实现了以下函数：<ul><li>read(char[] cbuf, int offset, int length) ：从offset位置开始，读取length个字符到cbuf中，返回结果是实际读取的字符数，到达流的末尾时，返回-1</li><li><strong>readLine()</strong> ：读取一个文本行，以行结束符作为末尾，返回结果是读取的<strong>字符串</strong>。如果已到达流末尾，则返回 null。这个方法比较常用。</li></ul></li></ul><h3 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2 使用"></a>3.1.2 使用</h3><ul><li><p>Reader 是一个抽象基类，不能实例化，但可以用于接口化编程。</p></li><li><p>InputStreamReader需要一个字节输入流对象作为实例化参数。还可以指定第二个参数，第二个参数是字符编码方式，可以是编码方式的字符串形式，也可以是一个字符集对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:/b.txt&quot;</span>));<br>        <span class="hljs-keyword">int</span> ch;<br>        <span class="hljs-keyword">while</span> ((ch = isr.read()) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.println( (<span class="hljs-keyword">char</span>)ch );<br>        &#125;<br>        isr.close();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;读取文件出错&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>FileReader 需要一个文件对象作为实例化参数，可以是File类对象，也可以是文件的路径字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           FileReader reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;D:/b.txt&quot;</span>);<br>           <span class="hljs-keyword">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];<br>           <span class="hljs-keyword">int</span> len;<br>           <span class="hljs-keyword">while</span> ((len = reader.read(cbuf)) != -<span class="hljs-number">1</span>)&#123;<br>               System.out.println(<span class="hljs-keyword">new</span> String(cbuf, <span class="hljs-number">0</span>, len));<br>           &#125;<br>           reader.close();<br>       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>           System.out.println(<span class="hljs-string">&quot;读取文件出错&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>BufferReader需要一个字符输入流对象作为实例化参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        FileReader reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;D:/b.txt&quot;</span>);<br>        BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(reader);<br>        String line;<br>        <span class="hljs-keyword">while</span> ( (line = bufferedReader.readLine()) != <span class="hljs-keyword">null</span>)&#123;<br>            System.out.println(line);<br>        &#125;<br>        bufferedReader.close();<br>        reader.close();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;读取文件出错&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是推荐的获取标准输入流的方法（从控制台获取输入）</span><br>BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-2-字符输出流"><a href="#3-2-字符输出流" class="headerlink" title="3.2 字符输出流"></a>3.2 字符输出流</h2><p>常见的字符输出流有：</p><ul><li>Writer</li><li>OutputStreamWriter</li><li>FileWriter</li><li>BufferedWriter</li></ul><h3 id="3-2-1-他们的区别与用途"><a href="#3-2-1-他们的区别与用途" class="headerlink" title="3.2.1 他们的区别与用途"></a>3.2.1 他们的区别与用途</h3><ul><li><p>Writer是字符输出流的抽象基类， ,它定义了以下几个函数</p><ul><li>write(char[] cbuf) :往输出流写入一个字符数组。</li><li>write(int c) ：往输出流写入一个字符。</li><li>write(String str) ：往输出流写入一串字符串。</li><li>write(String str, int off, int len) :往输出流写入字符串的一部分。</li><li>close() ：关闭流，释放资源。 【这个还是抽象的，写出来是说明有这个关闭功能】</li><li>flush()：刷新输出流，把数据马上写到输出流中。 【这个还是抽象的，写出来是说明有这个关闭功能】</li></ul></li><li><p>OutputStreamWriter可以使我们直接往流中写字符串数据，它里面会帮我们根据字符编码方式来把字符数据转成字节数据再写给输出流，它相当于一个中介\桥梁。</p></li><li><p>FileWriter与OutputStreamWriter功能类似，我们可以直接往流中写字符串数据，FileWriter内部会根据字符编码方式来把字符数据转成字节数据再写给输出流。</p></li><li><p>BufferedWriter比FileWriter还高级一点，它利用了缓冲区来提高写的效率。它还多出了一个函数：</p><ul><li>newLine() ：写入一个换行符。</li></ul></li></ul><h3 id="3-2-3-使用"><a href="#3-2-3-使用" class="headerlink" title="3.2.3 使用"></a>3.2.3 使用</h3><ul><li>Writer 是一个抽象基类，不能实例化，但可以用于接口化编程。</li><li>OutputStreamWriter 需要一个输入流对象作为实例化参数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:/b.txt&quot;</span>);<br>            OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(out);<br>            osw.write(<span class="hljs-string">&quot;你好啊&quot;</span>);<br>            osw.close();<br>            out.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;写入文件出错&quot;</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>FileWriter 需要一个文件对象来实例化，可以是File类对象，也可以是文件的路径字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           FileWriter writer = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;D:/b.txt&quot;</span>);<br>           writer.write(<span class="hljs-string">&quot;雷猴啊&quot;</span>);<br>           writer.close();<br>       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>           System.out.println(<span class="hljs-string">&quot;写入文件出错&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>BufferWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           FileWriter writer = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;D:/b.txt&quot;</span>);<br>           BufferedWriter bufferedWriter = <span class="hljs-keyword">new</span> BufferedWriter(writer);<br>           bufferedWriter.write(<span class="hljs-string">&quot;雷猴啊123456&quot;</span>);<br>           bufferedWriter.newLine();<br>           bufferedWriter.write(<span class="hljs-string">&quot;hhhhhh&quot;</span>);<br>           bufferedWriter.close();<br>           writer.close();<br>       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>           System.out.println(<span class="hljs-string">&quot;写入文件出错&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是推荐的标准输出的方式（输出到控制台）</span><br>Writer out = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(System.out));<br></code></pre></td></tr></table></figure></li></ul><h1 id="4、补充"><a href="#4、补充" class="headerlink" title="4、补充"></a>4、补充</h1><ul><li>上面的一些函数，考虑到效率问题，上面的子类可能会重写基类的函数，但功能基本是不变的。</li><li>更多关于字节流的函数与用法可以参考jdk文档。</li></ul><h1 id="5、参考资料"><a href="#5、参考资料" class="headerlink" title="5、参考资料"></a>5、参考资料</h1><p><a href="https://www.cnblogs.com/progor/p/9357676.html">https://www.cnblogs.com/progor/p/9357676.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节流</tag>
      
      <tag>字符流</tag>
      
      <tag>输入流</tag>
      
      <tag>输出流</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三步搞定Springboot项目发送邮件</title>
    <link href="/2022/03/31/%E4%B8%89%E6%AD%A5%E6%90%9E%E5%AE%9ASpringboot%E9%A1%B9%E7%9B%AE%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <url>/2022/03/31/%E4%B8%89%E6%AD%A5%E6%90%9E%E5%AE%9ASpringboot%E9%A1%B9%E7%9B%AE%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2、配置application-yml"><a href="#2、配置application-yml" class="headerlink" title="2、配置application.yml"></a>2、配置application.yml</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mail:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.office365.com</span>  <span class="hljs-comment">#这里用outlook邮箱</span><br>    <span class="hljs-attr">default-encoding:</span> <span class="hljs-string">utf-8</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">587</span>   <span class="hljs-comment">#端口号465或587</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">smtp</span><br>    <span class="hljs-comment"># 发送者邮箱账号，非必须配置项，可以从其它地方获取</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">XXX@outlook.com</span><br>    <span class="hljs-comment"># 发送者邮箱授权码，非必须配置项，但一定是发送者邮箱的授权码</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">xxxxxxxxx</span><br>    <span class="hljs-attr">properties:</span><br>      <span class="hljs-attr">mail:</span><br>        <span class="hljs-attr">debug:</span><br>          <span class="hljs-literal">true</span>   <span class="hljs-comment">#开启debug日志</span><br>        <span class="hljs-attr">smtp:</span><br>          <span class="hljs-attr">starttls:</span>  <span class="hljs-comment">#outlook邮箱需要配置这个属性</span><br>            <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>            <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">socketFactory:</span><br>            <span class="hljs-attr">class:</span> <span class="hljs-string">javax.net.ssl.SSLSocketFactory</span><br></code></pre></td></tr></table></figure><h1 id="3、发送代码"><a href="#3、发送代码" class="headerlink" title="3、发送代码"></a>3、发送代码</h1><p>PS：这是写在一个controller内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>   <span class="hljs-keyword">private</span> JavaMailSender mailSender;<br><br>   <span class="hljs-meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span><br>   <span class="hljs-keyword">private</span> String from;<br><br>   <span class="hljs-meta">@GetMapping(&quot;sendEmail&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendEmail</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-comment">//创建简单邮件消息</span><br>       SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();<br>       <span class="hljs-comment">//谁发的</span><br>       message.setFrom(from);<br>       <span class="hljs-comment">//谁要接收</span><br>       message.setTo(<span class="hljs-string">&quot;666666666@qq.com&quot;</span>);<br>       <span class="hljs-comment">//邮件标题</span><br>       message.setSubject(<span class="hljs-string">&quot;我是一个标题&quot;</span>);<br>       <span class="hljs-comment">//邮件内容</span><br>       message.setText(<span class="hljs-string">&quot;我是一个内容&quot;</span>);<br>       mailSender.send(message);<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>邮件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx解决跨域(CORS)问题</title>
    <link href="/2022/03/30/Nginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F-CORS-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/30/Nginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F-CORS-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="0、问题出现"><a href="#0、问题出现" class="headerlink" title="0、问题出现"></a>0、问题出现</h1><p>事情是这样的，我在Nginx里配置了两个服务，一个监听5000端口，用来代理前端，一个监听7000端口，用来代理后端。</p><p><img src="/2022/03/30/Nginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F-CORS-%E9%97%AE%E9%A2%98/image-20220331011053771.png" alt="nginx配置"></p><p>然而在前端调用后端接口时，浏览器报跨域错误</p><p><img src="/2022/03/30/Nginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F-CORS-%E9%97%AE%E9%A2%98/image-20220331011019132.png" alt="CORS错误"></p><p>再看一下控制台：</p><p><img src="/2022/03/30/Nginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F-CORS-%E9%97%AE%E9%A2%98/image-20220331011500727.png" alt="控制台报错"></p><h1 id="1、什么是跨域"><a href="#1、什么是跨域" class="headerlink" title="1、什么是跨域"></a>1、什么是跨域</h1><p>跨域是指a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，或是a页面为ip地址，b页面为域名地址，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。</p><p>跨域问题的根本原因：因为浏览器受到同源策略的限制，当前域名的js只能读取同域下的窗口属性。什么叫做同源策略？就是不同的域名, 不同端口, 不同的协议不允许共享资源的，保障浏览器安全。同源策略是针对浏览器设置的门槛。</p><p>只有访问类型为XHR（XMLHttpRequest)的才会出现跨域。XHR是基于XML的HTTP请求，XHR用于在后台与服务器交换数据。XHR是一个浏览器接口，使得Javascript可以进行HTTP(S)通信，ajax就是基于浏览器提供的XHR对象来实现的。ajax，可以实现异步的加载网页也就是说可以在不重新加载整个网页的情况下，对网页的某部分进行更新。浏览器端发送的请求只有XHR 或 fetch 发出的才是 ajax 请求, 其它所有的都是非 ajax 请求，ajax 请求是一种特别的 http 请求。当浏览器端接收到ajax 请求,浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据。</p><h1 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h1><p>在nginx中添加跨域配置，可以添加在server字段，应用于整个server，也可以添加在server:location字段下,应用于单个location。nginx配置文件通过使用add_header指令来设置响应头response header。当前层级无 add_header 指令时，则继承上一层级的add_header。相反的若当前层级有了add_header，就无法继承上一层的add_header。</p><figure class="highlight nginx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 指定允许的请求域名端口访问我们的跨域资源，*代表所有的域，也可设置具体域名　　　　 </span><br><span class="hljs-comment">#　add_header Access-Control-Allow-Origin *;　　　　</span><br><span class="hljs-comment">#当带cookie访问时不能用*，带cookie的请求不支持*号。$http_origin表示动态获取请求客户端请求的域。　　　　　</span><br><span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin $http_origin;　　　　　 <br><br><span class="hljs-comment"># 带cookie请求需要加上这个字段，并设置为true　　　　 </span><br><span class="hljs-attribute">add_header</span> Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;<br>   　　　　 <br><span class="hljs-comment"># 指定允许跨域的方法，*代表所有方法，$http_access_control_request_method指动态获取，也可设置具体方法。　　　　 </span><br><span class="hljs-comment"># add_header Access-Control-Allow-Methods $http_access_control_request_method;　　　　 </span><br><span class="hljs-comment">#如设置GET,POST,OPTIONS三种方法        </span><br><span class="hljs-attribute">add</span> header Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET, POST, OPTIOS&#x27;</span>;　　<br>　　　　 <br><span class="hljs-comment"># 表示请求头的字段,*表示所有字段　　　　 </span><br><span class="hljs-comment">#add_header Access-Control-Allow-Headers *;　　　　 </span><br><span class="hljs-comment">#动态获取　　　　 </span><br><span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers $http_access_control_request_headers;<br>　　　　 <br><span class="hljs-comment"># 预检命令的缓存，如果不缓存每次会发送两次请求 　　　　 </span><br><span class="hljs-attribute">add_header</span> Access-Control-Max-Age <span class="hljs-number">3600</span>; <br><br><span class="hljs-comment"># OPTIONS预检命令，预检命令通过时才发送请求 　　　　 </span><br><span class="hljs-comment"># 检查请求的类型是不是预检命令 　　　　 </span><br><span class="hljs-attribute">if</span> ($request_method = OPTIONS)&#123;　　　　　　 <br><span class="hljs-attribute">return</span> <span class="hljs-number">200</span>; 　　　　<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上述方案，我在后端服务加上如下配置：</p><p><img src="/2022/03/30/Nginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F-CORS-%E9%97%AE%E9%A2%98/image-20220331014727308.png" alt="nginx配置"></p><p>修改完后，nginx重新加载配置，问题就解决啦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -s reload<br></code></pre></td></tr></table></figure><br><br><p>当然，如果你的后端不用Nginx代理，前端直接访问后端的话，还可以用这种方法：</p><p>Springboot项目，添加一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解决前端跨域问题</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2022/3/28</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;<br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)<br>                .allowedMethods(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;OPTIONS&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>)<br>                .maxAge(<span class="hljs-number">3600</span>)<br>                .allowCredentials(<span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>其他语言的思路也差不多，就是在响应返回给浏览器之前，在response header里加上那几个参数就好了。<br>浏览器看到服务器返回的响应头里面有这几个参数，就不会报跨域的异常了</p><p><img src="/2022/03/30/Nginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F-CORS-%E9%97%AE%E9%A2%98/image-20220331021842883.png" alt="重要header"></p><h1 id="3、其他问题"><a href="#3、其他问题" class="headerlink" title="3、其他问题"></a>3、其他问题</h1><p>（1）加了上面的Nginx配置还有跨域问题，http状态码是4XX或5XX。</p><p>经百度发现，Nginx <strong>add_header</strong> 只对2XX，3XX 这些状态码生效，对于4XX，5XX这些状态码是不生效的。</p><p><strong>解决办法:</strong><code>添加: always</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin  $http_origin always;<br><span class="hljs-attribute">add_header</span> Access-Control-Allow-Credentials <span class="hljs-literal">true</span> always;<br></code></pre></td></tr></table></figure><p>这两个配置后面加上always就解决了。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>跨域</tag>
      
      <tag>CORS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Amis框架快速上手：使用Json配置生成前端页面</title>
    <link href="/2022/03/29/Amis%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Json%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"/>
    <url>/2022/03/29/Amis%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Json%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><p>作为一个后端打工人，我对前端是几乎完全不懂，当我想自己写一些项目玩的时候，前端怎么搞就成了一个难题。感觉前端的知识太多太杂，学起来很难，需要消耗比较多的时间精力。直到我发现了Amis，一个低代码前端框架，它使用 JSON 配置来生成页面，可以减少页面开发工作量，极大提升效率。对于前端小白的我来说，它就是一个神器啊，结合官方给出的demo，我们可以很快搭建出一个后台管理界面，基本上能满足我们日常的一些需求了。下面来说一下搭建过程。</p><h1 id="1、下载sdk"><a href="#1、下载sdk" class="headerlink" title="1、下载sdk"></a>1、下载sdk</h1><p>先新建一个<code>amis-project</code>目录，然后把最新发布的sdk下载到这个目录。</p><p>sdk地址：<a href="https://github.com/baidu/amis/releases">Releases · baidu/amis (github.com)</a></p><p><img src="/2022/03/29/Amis%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Json%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/image-20220329212319823.png" alt="sdk"></p><p>把<code>jssdk.tar.gz</code>直接解压，得到<code>jssdk</code>目录，里面就是我们要用到的sdk了，顺手把<code>jssdk.tar.gz</code>删除。</p><h1 id="2、下载amis-admin项目源码"><a href="#2、下载amis-admin项目源码" class="headerlink" title="2、下载amis-admin项目源码"></a>2、下载amis-admin项目源码</h1><p>amis-admin是一个官方demo，我们可以基于这个demo开发自己的项目。</p><p>项目地址：<a href="https://github.com/aisuda/amis-admin">aisuda/amis-admin: 基于 amis 的后台项目前端模板 (github.com)</a></p><p>直接下载zip压缩包，下载到任意位置然后解压，解压后得到如下文件。</p><p><img src="/2022/03/29/Amis%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Json%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/image-20220329213759371.png" alt="amis-admin源码"></p><p>我们只需要红框内的文件，其他的可以直接删除了，把红框内文件复制到<code>amis-project</code>目录下。最后，<code>amis-project</code>目录结构如下：</p><p><img src="/2022/03/29/Amis%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Json%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/image-20220329220934748.png" alt="目录结构"></p><p><code>page</code>是存放用于生成页面的json文件</p><p><code>public</code>是存放一些图片之类的文件</p><p><code>index.html</code>就是主页了，它会读取<code>page</code>目录下的文件渲染生成一个个页面。打开<code>index.html</code>修改一下sdk的路径，如下图：</p><p><img src="/2022/03/29/Amis%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Json%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/image-20220329222646412.png" alt="修改文件地址"></p><h1 id="3、配置Nginx"><a href="#3、配置Nginx" class="headerlink" title="3、配置Nginx"></a>3、配置Nginx</h1><p>先到<a href="http://nginx.org/en/download.html">Nginx官网</a>下载Windows版本，解压后打开conf目录，找到<code>nginx.conf</code>文件打开，加入如下配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">7000</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-attribute">root</span>   D:/amis-project;<br>            <span class="hljs-attribute">index</span>  index.html;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>然后启动nginx，浏览器输入<a href="http://localhost:7000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E9%A1%B5%E9%9D%A2%E4%BA%86%E3%80%82">http://localhost:7000/，就可以看到页面了。</a></p><p><img src="/2022/03/29/Amis%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Json%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/image-20220329221226847.png" alt="amis-admin页面"></p><h1 id="4、结语"><a href="#4、结语" class="headerlink" title="4、结语"></a>4、结语</h1><p>把项目搭建起来之后，后续要做的就是对照着页面和代码，修改成自己想要样子了。开始前先看看<a href="https://aisuda.bce.baidu.com/amis/zh-CN/docs/index">官方文档</a>，设计页面可以使用<a href="http://aisuda.github.io/amis-editor-demo">amis 可视化编辑器</a>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Amis</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>纯ipv6服务器建站</title>
    <link href="/2022/03/25/%E7%BA%AFipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%99/"/>
    <url>/2022/03/25/%E7%BA%AFipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><p>前段时间搞了个<a href="https://hax.co.id/home/">Hax</a>的免费服务器，1核450M内存5G硬盘，申请过程可以百度一下，非常简单。不过这个服务器是纯ipv6的，没有ipv4地址。我之前在Freenom上申请了两个域名（<a href="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/">申请方法看这篇文章</a>），但是没有在国内备案，不能解析到我那台腾讯云的服务器，所以想着把域名解析到Hax的服务器上玩玩。但是因为这个没有ipv4地址，而我的网络又不支持ipv6，所以想要在上面建站需要费一番功夫，研究了好几天终于弄明白，下面说一下大概过程。</p><h1 id="1、安装warp"><a href="#1、安装warp" class="headerlink" title="1、安装warp"></a>1、安装warp</h1><p>ssh登录机器，执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">wget -N https://cdn.jsdelivr.net/gh/fscarmen/warp/menu.sh &amp;&amp; bash menu.sh<br></code></pre></td></tr></table></figure><p>这样我们的机器就有了访问ipv4的能力</p><h1 id="2、-可选-安装宝塔面板"><a href="#2、-可选-安装宝塔面板" class="headerlink" title="2、(可选)安装宝塔面板"></a>2、(可选)安装宝塔面板</h1><p>执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh<br></code></pre></td></tr></table></figure><h1 id="3、安装nginx"><a href="#3、安装nginx" class="headerlink" title="3、安装nginx"></a>3、安装nginx</h1><p>在宝塔面板里面安装。</p><p><img src="/2022/03/25/%E7%BA%AFipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%99/image-20220326170111179.png" alt="安装nginx"></p><p>PS：如果不想安装宝塔面板，也可以直接安装nginx，参考教程<a href="https://www.cnblogs.com/chinaWu/p/14035181.html">Linux nginx安装篇</a></p><h1 id="4、监听ipv6"><a href="#4、监听ipv6" class="headerlink" title="4、监听ipv6"></a>4、监听ipv6</h1><p>最新版的nginx已经默认支持ipv6，不需要重新编译ipv6模块，所以只需要在配置文件里加入ipv6监听就可以了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">listen <span class="hljs-selector-attr">[::]</span>:<span class="hljs-number">80</span> ipv6only=on;<br></code></pre></td></tr></table></figure><p><img src="/2022/03/25/%E7%BA%AFipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%99/image-20220325183334402.png" alt="nginx配置"></p><p>保存后重载配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service nginx reload<br></code></pre></td></tr></table></figure><p>检测监听是否已经成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -tuln<br></code></pre></td></tr></table></figure><p><img src="/2022/03/25/%E7%BA%AFipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%99/image-20220325183651051.png" alt="80端口ipv6已监听成功"></p><h1 id="5、使用Cloudflare解析域名"><a href="#5、使用Cloudflare解析域名" class="headerlink" title="5、使用Cloudflare解析域名"></a>5、使用Cloudflare解析域名</h1><p>Cloudflare有免费的CDN和DNS服务，非常良心，而且用它代理ipv6服务器后，我们在ipv4的环境也可以访问服务器，这就很方便了。</p><p>先注册一个Cloudflare账号，访问<a href="http://dash.cloudflare.com/">dash.cloudflare.com</a>登录后点击添加站点，选择免费计划，之后按照页面提示操作。</p><p><img src="/2022/03/25/%E7%BA%AFipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%99/image-20220326163121310.png" alt="免费计划"></p><p>把域名托管到Cloudflare之后。点击DNS，添加记录，类型为AAAA，名称填@，然后输入服务器的ipv6地址，勾上代理状态，保存。</p><p><img src="/2022/03/25/%E7%BA%AFipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%99/image-20220326164029075.png" alt="添加DNS解析记录"></p><p><img src="/2022/03/25/%E7%BA%AFipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%99/image-20220326164226384.png" alt="填写内容"></p><p>然后将SSL/TLS加密方式设置为灵活</p><p><img src="/2022/03/25/%E7%BA%AFipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%99/image-20220326164503046.png" alt="SSL/TLS加密方式设置为灵活"></p><p>然后浏览器访问你的域名就可以啦。</p><h1 id="6、CloudFlare支持的端口"><a href="#6、CloudFlare支持的端口" class="headerlink" title="6、CloudFlare支持的端口"></a>6、CloudFlare支持的端口</h1><p>使用CloudFlare的代理不仅支持常规的80和443端口，还支持以下端口</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">HTTP ports supported by Cloudflare:</span><br><span class="hljs-number">80</span><br><span class="hljs-number">8080</span><br><span class="hljs-number">8880</span><br><span class="hljs-number">2052</span><br><span class="hljs-number">2082</span><br><span class="hljs-number">2086</span><br><span class="hljs-number">2095</span><br><span class="hljs-attr">HTTPS ports supported by Cloudflare:</span><br><span class="hljs-number">443</span><br><span class="hljs-number">2053</span><br><span class="hljs-number">2083</span><br><span class="hljs-number">2087</span><br><span class="hljs-number">2096</span><br><span class="hljs-number">8443</span><br></code></pre></td></tr></table></figure><p>比如，修改宝塔的面板端口为8080</p><p><img src="/2022/03/25/%E7%BA%AFipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%99/image-20220326165301020.png" alt="修改面板端口"></p><p>然后勾上监听ipv6</p><p><img src="/2022/03/25/%E7%BA%AFipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%99/image-20220326165411241.png" alt="勾上监听ipv6"></p><p>就可以使用 <code>http://域名:8080</code>访问我们的宝塔面板啦。</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>ipv6</tag>
      
      <tag>Cloudflare</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Charles转发网络请求到自己的应用</title>
    <link href="/2022/03/24/%E4%BD%BF%E7%94%A8Charles%E8%BD%AC%E5%8F%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2022/03/24/%E4%BD%BF%E7%94%A8Charles%E8%BD%AC%E5%8F%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><p>平时我们在工作中可能经常会遇到这种情况，在测试环境我们的一个接口出问题了，但是没办法看日志（比如elk查不到日志啦，或者没权限登录服务器查看啦，又或者应用部署了很多台机器，不知道看那台机器的日志啦。。。），这种时候我们一般会想在自己的电脑上复现一下，看看报什么错。当你在本地启动应用，打开Postman准备调一下本地接口的时候，另一个问题出现了，这接口参数也太多了吧，一个个输太麻烦了！！！这时候就可以用Charles来解决问题了，Charles是一个抓包工具，经过简单配置就可以把浏览器的网络请求转发到我们本地的应用。</p><h1 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h1><p>打开<a href="https://www.charlesproxy.com/download/">官网</a>下载并安装Charles</p><h1 id="2、激活"><a href="#2、激活" class="headerlink" title="2、激活"></a>2、激活</h1><p>打开<a href="https://www.zzzmode.com/mytools/charles/">这个网站</a></p><p><img src="/2022/03/24/%E4%BD%BF%E7%94%A8Charles%E8%BD%AC%E5%8F%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8/image-20220324200539651.png" alt="生成激活码"></p><br><p>随便输入一个名称，点击生成。</p><p><img src="/2022/03/24/%E4%BD%BF%E7%94%A8Charles%E8%BD%AC%E5%8F%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8/image-20220324200744889.png" alt="复制激活码"></p><br><p>复制好激活码，打开Charles，点击 Help –&gt; Register Charles</p><p><img src="/2022/03/24/%E4%BD%BF%E7%94%A8Charles%E8%BD%AC%E5%8F%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8/image-20220324200930670.png" alt="点击激活"></p><br><p>然后输入刚才的名称和激活码</p><p><img src="/2022/03/24/%E4%BD%BF%E7%94%A8Charles%E8%BD%AC%E5%8F%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8/image-20220324201114747.png" alt="输入激活码"></p><br><p>激活成功，点击确定，然后重新打开Charles</p><p><img src="/2022/03/24/%E4%BD%BF%E7%94%A8Charles%E8%BD%AC%E5%8F%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8/image-20220324201306520.png" alt="激活成功"></p><h1 id="3、Map-Remote"><a href="#3、Map-Remote" class="headerlink" title="3、Map Remote"></a>3、Map Remote</h1><p>使用Charles的Map Remote功能就可以实现把网络请求转发到本地了。点击 Tools –&gt; Map Remote</p><p><img src="/2022/03/24/%E4%BD%BF%E7%94%A8Charles%E8%BD%AC%E5%8F%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8/image-20220324201801941.png" alt="Map Remote"></p><br><p>然后按下图所示操作</p><p><img src="/2022/03/24/%E4%BD%BF%E7%94%A8Charles%E8%BD%AC%E5%8F%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8/image-20220324202028813.png" alt="添加规则"></p><p><img src="/2022/03/24/%E4%BD%BF%E7%94%A8Charles%E8%BD%AC%E5%8F%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8/image-20220324202502742.png" alt="填写匹配规则"></p><br><p>设置完成后，点击ok</p><p><img src="/2022/03/24/%E4%BD%BF%E7%94%A8Charles%E8%BD%AC%E5%8F%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8/image-20220324202649515.png" alt="点击ok"></p><br><p>到浏览器测试一下，成功。<code>zahi.cf/emp/1</code>被转发到本地的 <code>127.0.0.1:8000/emp/1</code> </p><p><img src="/2022/03/24/%E4%BD%BF%E7%94%A8Charles%E8%BD%AC%E5%8F%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8/image-20220324202928799.png" alt="测试"></p><h1 id="4、结语"><a href="#4、结语" class="headerlink" title="4、结语"></a>4、结语</h1><p>经过这样配置之后，我们就可以在前端正常操作，前端原本要发给服务器的请求会被Charles转发到本地的应用，后端就可以获取所有参数，复现问题，这样就不需要用Postman自己组装参数，也不需要找前端联调了（万一被打）。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Charles</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins关闭/重启及常见问题</title>
    <link href="/2022/03/08/Jenkins%E5%85%B3%E9%97%AD-%E9%87%8D%E5%90%AF%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/08/Jenkins%E5%85%B3%E9%97%AD-%E9%87%8D%E5%90%AF%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1、启动-Jenkins"><a href="#1、启动-Jenkins" class="headerlink" title="1、启动 Jenkins"></a>1、启动 Jenkins</h1><p>一般在启动的时候指定它的端口号</p><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">java -jar jenkins.war --httpPort=8080<br></code></pre></td></tr></table></figure><p>然后就可以通过 <a href="http://localhost:8080/">http://localhost:8080/</a> 去访问它了。</p><h1 id="2、关闭-Jenkins"><a href="#2、关闭-Jenkins" class="headerlink" title="2、关闭 Jenkins"></a>2、关闭 Jenkins</h1><p>可以通过URL的方式关闭它，浏览器输入</p><p> <a href="http://localhost:8080/exit">http://localhost:8080/exit</a></p><p>出现如下页面，点击使用POST重试，然后 Jenkins 就关闭了</p><p><img src="/2022/03/08/Jenkins%E5%85%B3%E9%97%AD-%E9%87%8D%E5%90%AF%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image-20220308142059709.png" alt="关闭"></p><br><h1 id="3、重启-Jenkins"><a href="#3、重启-Jenkins" class="headerlink" title="3、重启 Jenkins"></a>3、重启 Jenkins</h1><p>如果是 Windows 用户，需要先在首页 —-&gt; Manage Jenkins —-&gt; Install as Windows service( 设置为Windows服务 ) ，点击安装即可，否则重启会报错 <em>Jenkins cannot restart itself as currently configured.</em></p><p><img src="/2022/03/08/Jenkins%E5%85%B3%E9%97%AD-%E9%87%8D%E5%90%AF%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/win.png" alt="windows用户操作"></p><br><p>在浏览器输入以下链接即可重启</p><p><a href="http://localhost:8080/restart">http://localhost:8080/restart</a></p><p><img src="/2022/03/08/Jenkins%E5%85%B3%E9%97%AD-%E9%87%8D%E5%90%AF%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image-20220308143348817.png" alt="确定重启"></p><p><img src="/2022/03/08/Jenkins%E5%85%B3%E9%97%AD-%E9%87%8D%E5%90%AF%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image-20220308143500383.png" alt="重启中..."></p><h1 id="4、重载-Jenkins-配置信息"><a href="#4、重载-Jenkins-配置信息" class="headerlink" title="4、重载 Jenkins 配置信息"></a>4、重载 Jenkins 配置信息</h1><p>浏览器输入：</p><p><a href="http://localhost:8080/reload">http://localhost:8080/reload</a></p><h1 id="5、常见问题"><a href="#5、常见问题" class="headerlink" title="5、常见问题"></a>5、常见问题</h1><p>昨天直接在任务管理器把 Jenkins 关掉后，再次打开，发现自己的项目不见了😭坑啊，找了一圈方法，没有适合我的，只能重新配一次了。所以一定要用正确的方法关闭Jenkins，不然会出现不可预料的问题。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot集成分布式定时任务调度平台xxl-job</title>
    <link href="/2022/03/08/Springboot%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0xxl-job/"/>
    <url>/2022/03/08/Springboot%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0xxl-job/</url>
    
    <content type="html"><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><p>大家平时在工作中应该经常用到定时任务，可能使用过Quartz框架或者Spring自带@Scheduled注解来实现定时任务，今天来介绍一个更加简单好用、功能强大的定时任务框架：xxl-job。xxl-job提供了一个管理界面，可以对定时任务进行增删改查、手动执行，还可以查看每一次的执行日志，支持集群部署，支持调度策略。下面简单介绍一下Springboot集成xxl-job的过程，更加详细的玩法请看官方文档。</p><h1 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h1><h4 id="文档地址"><a href="#文档地址" class="headerlink" title="文档地址"></a>文档地址</h4><ul><li><a href="https://www.xuxueli.com/xxl-job/">中文文档</a></li></ul><table><thead><tr><th align="left">源码仓库地址</th><th align="left">Release Download</th></tr></thead><tbody><tr><td align="left"><a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a></td><td align="left"><a href="https://github.com/xuxueli/xxl-job/releases">Download</a></td></tr><tr><td align="left"><a href="http://gitee.com/xuxueli0323/xxl-job">http://gitee.com/xuxueli0323/xxl-job</a></td><td align="left"><a href="http://gitee.com/xuxueli0323/xxl-job/releases">Download</a></td></tr></tbody></table><h4 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h4><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.xuxueli/xxl-job-core --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuxueli<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xxl-job-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2、环境"><a href="#2、环境" class="headerlink" title="2、环境"></a>2、环境</h1><ul><li><p>Maven3+</p></li><li><p>Jdk1.8+</p></li><li><p>Mysql5.7+</p></li></ul><h1 id="3、部署调度中心"><a href="#3、部署调度中心" class="headerlink" title="3、部署调度中心"></a>3、部署调度中心</h1><h2 id="3-1-获取源码"><a href="#3-1-获取源码" class="headerlink" title="3.1 获取源码"></a>3.1 获取源码</h2><p>下载项目源码并解压，得到的目录结构为</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cos">xxl-<span class="hljs-keyword">job</span>-<span class="hljs-number">2.3</span><span class="hljs-number">.0</span>:<br>doc: 官方文档和数据库sql<br>    xxl-<span class="hljs-keyword">job</span>-admin：调度中心<br>    xxl-<span class="hljs-keyword">job</span>-core：公共依赖<br>    xxl-<span class="hljs-keyword">job</span>-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）<br>        ：xxl-<span class="hljs-keyword">job</span>-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；<br>        ：xxl-<span class="hljs-keyword">job</span>-executor-sample-frameless：无框架版本；<br></code></pre></td></tr></table></figure><h2 id="3-2-初始化“调度数据库”"><a href="#3-2-初始化“调度数据库”" class="headerlink" title="3.2 初始化“调度数据库”"></a>3.2 初始化“调度数据库”</h2><p>执行以下sql:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/doc/</span>db/tables_xxl_job.sql<br></code></pre></td></tr></table></figure><h2 id="3-3-配置调度中心"><a href="#3-3-配置调度中心" class="headerlink" title="3.3 配置调度中心"></a>3.3 配置调度中心</h2><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">调度中心项目：xxl-<span class="hljs-keyword">job</span>-admin<br>作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台。<br></code></pre></td></tr></table></figure><p>调度中心配置文件地址：</p><div class="code-wrapper"><pre><code class="hljs">/xxl-job-admin/src/main/resources/application.properties</code></pre></div><p>调度中心主要配置内容说明：</p><div class="code-wrapper"><pre><code class="hljs">### webserver.port=8080server.servlet.context-path=/xxl-job-admin### 调度中心JDBC链接spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=root_pwdspring.datasource.driver-class-name=com.mysql.jdbc.Driver### 报警邮箱spring.mail.host=smtp.qq.comspring.mail.port=25spring.mail.username=xxx@qq.comspring.mail.password=xxxspring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory### 调度中心通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 调度中心国际化配置 [必填]： 默认为 &quot;zh_CN&quot;/中文简体, 可选范围为 &quot;zh_CN&quot;/中文简体, &quot;zh_TC&quot;/中文繁体 and &quot;en&quot;/英文；xxl.job.i18n=zh_CN## 调度线程池最大线程配置【必填】xxl.job.triggerpool.fast.max=200xxl.job.triggerpool.slow.max=100### 调度中心日志表数据保存天数 [必填]：过期日志自动清理；限制大于等于7时生效，否则, 如-1，关闭自动清理功能；xxl.job.logretentiondays=30</code></pre></div><p><strong>对我来说，只要配置一下服务端口、JDBC链接、数据库用户名密码就好了，其他的不用改。</strong></p><br><h2 id="3-4-编译部署调度中心"><a href="#3-4-编译部署调度中心" class="headerlink" title="3.4 编译部署调度中心"></a>3.4 编译部署调度中心</h2><p>执行以下命令</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> xxl-job-admin<br><span class="hljs-attribute">mvn</span> clean package<br><span class="hljs-attribute">cd</span> target<br><span class="hljs-attribute">java</span> -jar xxl-job-admin-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.jar<br></code></pre></td></tr></table></figure><p>服务起来后，访问调度中心地址：<a href="http://localhost:8080/xxl-job-admin">http://localhost:8080/xxl-job-admin</a> (该地址执行器将会使用到，作为回调地址)</p><p>默认登录账号 “admin/123456”, 登录后运行界面如下图所示。</p><p><img src="/2022/03/08/Springboot%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0xxl-job/image-20220309170818307.png" alt="管理界面"></p><p>至此“调度中心”项目已经部署成功。</p><h1 id="4、部署“执行器”"><a href="#4、部署“执行器”" class="headerlink" title="4、部署“执行器”"></a>4、部署“执行器”</h1><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">“执行器”项目：xxl-<span class="hljs-keyword">job</span>-executor-sample-springboot (提供多种版本执行器供选择，现以 springboot 版本为例，可直接使用，也可以参考其并将现有项目改造成执行器)<br>作用：负责接收“调度中心”的调度并执行；可直接部署执行器，也可以将执行器集成到现有业务项目中。<br></code></pre></td></tr></table></figure><p>这里我没有用这个样例项目，而是直接改造原有的项目。</p><h2 id="4-1-引入maven依赖"><a href="#4-1-引入maven依赖" class="headerlink" title="4.1 引入maven依赖"></a>4.1 引入maven依赖</h2><p>确认pom文件中引入了 “xxl-job-core” 的maven依赖；</p><h2 id="4-2-执行器的配置"><a href="#4-2-执行器的配置" class="headerlink" title="4.2 执行器的配置"></a>4.2 执行器的配置</h2><p>执行器配置，配置文件地址：</p><div class="code-wrapper"><pre><code class="hljs">/xxl-job-executor-samples/xxl-job-executor-sample-springboot/src/main/resources/application.properties</code></pre></div><p>执行器配置，主要配置内容说明：</p><div class="code-wrapper"><pre><code class="hljs">### 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin### 执行器通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册xxl.job.executor.appname=xxl-job-executor-sample### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。xxl.job.executor.address=### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；xxl.job.executor.ip=### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；xxl.job.executor.port=9999### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；xxl.job.executor.logretentiondays=30</code></pre></div><p><strong>因为我的项目使用的是yml文件的配置，所以配置如下内容就好了</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">xxl:</span><br>  <span class="hljs-attr">job:</span><br>    <span class="hljs-attr">admin:</span><br>      <span class="hljs-attr">addresses:</span> <span class="hljs-string">http://localhost:8080/xxl-job-admin</span> <span class="hljs-comment">#填上调度中心地址，就可以自动注册</span><br>    <span class="hljs-attr">accessToken:</span><br>    <span class="hljs-attr">executor:</span><br>      <span class="hljs-attr">appname:</span> <span class="hljs-string">xxl-job-executor-emp</span> <span class="hljs-comment">#执行器名称也填上</span><br>      <span class="hljs-attr">address:</span><br>      <span class="hljs-attr">ip:</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">8002</span><span class="hljs-comment">#端口也填上，防止端口冲突</span><br>      <span class="hljs-attr">logpath:</span> <span class="hljs-string">/log/xxl-job/jobhandler</span><span class="hljs-comment">#日志路径建议填上，方便自己查日志</span><br>      <span class="hljs-attr">logretentiondays:</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><h2 id="4-3-执行器组件"><a href="#4-3-执行器组件" class="headerlink" title="4.3 执行器组件"></a>4.3 执行器组件</h2><p>新建一个类 <code>XxlJobConfig</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> com.xxl.job.core.executor.impl.XxlJobSpringExecutor;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Value;<br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XxlJobConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(XxlJobConfig.<span class="hljs-keyword">class</span>);<br><br>    <span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;<span class="hljs-subst">$&#123;xxl.job.admin.addresses&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String adminAddresses;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;<span class="hljs-subst">$&#123;xxl.job.accessToken&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String accessToken;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;<span class="hljs-subst">$&#123;xxl.job.executor.appname&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String appname;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;<span class="hljs-subst">$&#123;xxl.job.executor.address&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;<span class="hljs-subst">$&#123;xxl.job.executor.ip&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String ip;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;<span class="hljs-subst">$&#123;xxl.job.executor.port&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> int port;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;<span class="hljs-subst">$&#123;xxl.job.executor.logpath&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String logPath;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;<span class="hljs-subst">$&#123;xxl.job.executor.logretentiondays&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> int logRetentionDays;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> XxlJobSpringExecutor xxlJobExecutor() &#123;<br>        logger.info(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);<br>        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();<br>        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);<br>        xxlJobSpringExecutor.setAppname(appname);<br>        xxlJobSpringExecutor.setAddress(address);<br>        xxlJobSpringExecutor.setIp(ip);<br>        xxlJobSpringExecutor.setPort(port);<br>        xxlJobSpringExecutor.setAccessToken(accessToken);<br>        xxlJobSpringExecutor.setLogPath(logPath);<br>        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);<br>        <span class="hljs-keyword">return</span> xxlJobSpringExecutor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-开发第一个定时任务“Hello-World”"><a href="#4-4-开发第一个定时任务“Hello-World”" class="headerlink" title="4.4 开发第一个定时任务“Hello World”"></a>4.4 开发第一个定时任务“Hello World”</h2><p>新建一个类 <code>SampleXxlJob</code></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> com.xxl.job.core.<span class="hljs-keyword">handler</span>.annotation.XxlJob;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleXxlJob</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(SampleXxlJob.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1、简单任务示例（Bean模式）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@XxlJob</span>(<span class="hljs-string">&quot;testXxlJob&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testXxlJob</span><span class="hljs-params">()</span></span>&#123;<br>        logger.info(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-5-部署执行器项目"><a href="#4-5-部署执行器项目" class="headerlink" title="4.5 部署执行器项目"></a>4.5 部署执行器项目</h2><p>可以直接在idea上运行，也可以打包部署到服务器上。</p><p>访问调度中心地址：<a href="http://localhost:8080/xxl-job-admin">http://localhost:8080/xxl-job-admin</a></p><p>点击“<strong>执行器管理</strong>”，再点击“<strong>新增</strong>”</p><p><img src="/2022/03/08/Springboot%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0xxl-job/image-20220309174153970.png" alt="新增执行器"></p><p>AppName：填写前面yml文件里配置的AppName，</p><p>名称：随便填</p><p>注册方式：自动注册（前面yml文件配置了调度中心的地址，所以可以自动注册）</p><p>机器地址：不需要填</p><p><img src="/2022/03/08/Springboot%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0xxl-job/image-20220309174357850.png" alt="填写信息"></p><p>点击保存，稍等一会，Online机器地址就会出现一个数字，点击查看，就是你的执行器的地址，说明执行器已经注册到调度中心了。</p><p><img src="/2022/03/08/Springboot%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0xxl-job/image-20220309175009314.png" alt="在线机器地址"></p><h2 id="4-6-在调度中心新增任务"><a href="#4-6-在调度中心新增任务" class="headerlink" title="4.6 在调度中心新增任务"></a>4.6 在调度中心新增任务</h2><p>点击 <strong>任务管理</strong> ，执行器选择刚才新增的执行器，再点击新增。</p><p><img src="/2022/03/08/Springboot%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0xxl-job/image-20220309175518239.png" alt="新增定时任务"></p><p>填写如下信息，JobHandler填写 <strong>@XxlJob</strong> 注解里面的内容。高级配置按需要填写，也可按默认配置。填完后点击保存。</p><p><img src="/2022/03/08/Springboot%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0xxl-job/image-20220309180310501.png" alt="填写任务信息"></p><p>刚新增的任务是停止状态，要点击启动，到了时间才会执行任务。</p><p><img src="/2022/03/08/Springboot%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0xxl-job/image-20220309180815995.png" alt="启动任务"></p><p>也可以点击<strong>执行一次</strong>马上执行任务，任务参数和机器地址不用填，直接点保存</p><p><img src="/2022/03/08/Springboot%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0xxl-job/image-20220309181051686.png" alt="执行一次"></p><p><img src="/2022/03/08/Springboot%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0xxl-job/image-20220309181349539.png" alt="查看控制台日志"></p><p>点击左边的<strong>调度日志</strong>（这里需要点击任务id才能知道是哪个任务，我觉得这个体验不是很好哈）</p><p><img src="/2022/03/08/Springboot%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0xxl-job/image-20220309181836081.png" alt="查看调度日志"></p><br><p>最后，本文只是一个入门指引，其他高级玩法去翻官方文档哈。</p><p>END</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>xxl-job</tag>
      
      <tag>定时任务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot整合mybatis</title>
    <link href="/2022/03/06/Springboot%E6%95%B4%E5%90%88mybatis/"/>
    <url>/2022/03/06/Springboot%E6%95%B4%E5%90%88mybatis/</url>
    
    <content type="html"><![CDATA[<p>继上篇 <a href="/2019/10/21/Springboot-Druid%E9%85%8D%E7%BD%AE/">Springboot整合Druid</a> 之后，下面继续记录一下Springboot整合mybatis的过程。</p><p>1、引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `wx_message`<br>(<br>    `id`                  <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>    `msg_id`              <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">unique</span>  COMMENT <span class="hljs-string">&#x27;消息ID&#x27;</span>,<br>    `user_id`             <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;用户ID(一个OpenID)&#x27;</span>,<br>    `msg_type`            <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;消息类型&#x27;</span>,<br>    `receive_msg`         <span class="hljs-type">varchar</span>(<span class="hljs-number">2048</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;收到的消息&#x27;</span>,<br>    `response_msg`        <span class="hljs-type">varchar</span>(<span class="hljs-number">2048</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;回复的消息&#x27;</span>,<br>    `create_date`         datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>  COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8mb4<br>  <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8mb4_unicode_ci COMMENT <span class="hljs-operator">=</span><span class="hljs-string">&#x27;公众号微信消息&#x27;</span>;<br></code></pre></td></tr></table></figure><p>3、创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WxMessage</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> msgId;<br>    <span class="hljs-keyword">private</span> String msgType;<br>    <span class="hljs-keyword">private</span> String userId;<br>    <span class="hljs-keyword">private</span> String receiveMsg;<br>    <span class="hljs-keyword">private</span> String responseMsg;<br>    <span class="hljs-keyword">private</span> Date createDate;<br>    <span class="hljs-comment">//省略getter和setter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>4、创建mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WxMessageMapper</span> </span>&#123;<br><br>    <span class="hljs-function">List&lt;WxMessage&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(WxMessage message)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>5、在resources目录下创建WxMessageMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.zahi.hrms.employee.mapper.WxMessageMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;WxMessage&quot;</span>&gt;</span><br>        select * from wx_message<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;WxMessage&quot;</span>&gt;</span><br>        insert into wx_message (msg_id, user_id, msg_type, receive_msg, response_msg, create_date)<br>                        values (#&#123;msgId&#125;, #&#123;userId&#125;, #&#123;msgType&#125;, #&#123;receiveMsg&#125;, #&#123;responseMsg&#125;, #&#123;createDate&#125; )<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：</p><p>(1) 这个文件的名字和上面的mapper接口的类名一致</p><p>(2) namespace是上面mapper接口的全限定类名</p><p>(3) select / insert等标签的id要和mapper接口里的方法名一致</p><br><p>ps：到现在主要目录结构如下</p><div align="center"><img src="/2022/03/06/Springboot%E6%95%B4%E5%90%88mybatis/image-20220306172657618.png" alt="目录结构" style="zoom:50%;"></div><p>6、在启动类里面添加MapperScan注解，扫描所有mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.zahi.hrms.employee.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EmployeeApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>7、在application.yml添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#mybatis的相关配置</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-comment">#mapper配置文件</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/*.xml</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.zahi.hrms.employee.entity</span><br>  <span class="hljs-comment">#开启驼峰命名</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>ps：配置type-aliases-package之后，上面的WxMessageMapper.xml里面的resultType和parameterType就可以只写类名，不用写全限定类名了。</p><br><p>END</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义spring项目启动banner</title>
    <link href="/2022/03/05/%E8%87%AA%E5%AE%9A%E4%B9%89spring%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8banner/"/>
    <url>/2022/03/05/%E8%87%AA%E5%AE%9A%E4%B9%89spring%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8banner/</url>
    
    <content type="html"><![CDATA[<p>我们在启动Spring项目的时候，经常会看到下面这个玩意</p><img src="/2022/03/05/%E8%87%AA%E5%AE%9A%E4%B9%89spring%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8banner/image-20220305172914330.png" alt="Spring启动banner" style="zoom: 67%;"><br><p>其实这个也是可以改的，今天就来说一下怎么自定义这个banner</p><br><p>首先，在项目的<code>resources</code>目录下新建一个<code>banner.txt</code></p><p><img src="/2022/03/05/%E8%87%AA%E5%AE%9A%E4%B9%89spring%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8banner/image-20220305173152848.png" alt="banner.txt"></p><br><p>然后去生成banner网站生成自己想要的banner，这里推荐几个好用的网站</p><p><a href="https://www.bootschool.net/ascii">https://www.bootschool.net/ascii</a></p><p><a href="http://patorjk.com/software/taag">http://patorjk.com/software/taag</a></p><p><a href="http://www.network-science.de/ascii">http://www.network-science.de/ascii</a></p><br><p>还有这个，能把图片转换成文本，非常牛B</p><p><a href="https://www.degraeve.com/img2txt.php">https://www.degraeve.com/img2txt.php</a></p><img src="/2022/03/05/%E8%87%AA%E5%AE%9A%E4%B9%89spring%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8banner/image-20220305175149191.png" alt="图片转文本" style="zoom: 33%;"><br><p>生成好banner后，把内容拷到banner.txt里面就好了</p><br><br><p>PS：还能通过一些属性来设置banner</p><figure class="highlight stata"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs stata"><span class="hljs-variable">$&#123;AnsiColor</span>.BRIGHT_RED&#125; ：设置控制台中输出内容的颜色<br><span class="hljs-variable">$&#123;application</span>.<span class="hljs-keyword">version</span>&#125; ：用来获取`MANIFEST.MF` 文件中的版本号<br><span class="hljs-variable">$&#123;application</span>.formatted-<span class="hljs-keyword">version</span>&#125; ：格式化后的`<span class="hljs-variable">$&#123;application</span>.<span class="hljs-keyword">version</span>&#125;` 版本信息<br><span class="hljs-variable">$&#123;spring</span>-<span class="hljs-keyword">boot</span>.<span class="hljs-keyword">version</span>&#125; ：Spring <span class="hljs-keyword">Boot</span>的版本号<br><span class="hljs-variable">$&#123;spring</span>-<span class="hljs-keyword">boot</span>.formatted-<span class="hljs-keyword">version</span>&#125; ：格式化后的`<span class="hljs-variable">$&#123;spring</span>-<span class="hljs-keyword">boot</span>.<span class="hljs-keyword">version</span>&#125;` 版本信息<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean">$&#123;AnsiColor.BRIGHT_GREEN&#125;<br>########    ###    ##     ## #### <br>     ##    ## ##   ##     ##  ##  <br>    ##    ##   ##  ##     ##  ##  <br>   ##    ##     ## #########  ##  <br>  ##     ######### ##     ##  ##  <br> ##      ##     ## ##     ##  ##  <br>######## ##     ## ##     ## #### <br>$&#123;AnsiColor.BRIGHT_RED&#125;<br>Application Version: $&#123;application.version&#125;$&#123;application.formatted-version&#125;<br>Spring Boot Version: $&#123;spring-boot.version&#125;$&#123;spring-boot.formatted-version&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>Springboot</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins安装记录</title>
    <link href="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="0、简介"><a href="#0、简介" class="headerlink" title="0、简介"></a>0、简介</h1><p>Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，主要用于持续、自动的构建/测试软件项目。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。</p><p>简而言之就是，<strong>一键完成拉代码、编译、构建、部署等任务</strong>。</p><h1 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h1><p>1.1 下载最新<a href="http://mirrors.jenkins.io/war-stable/latest/jenkins.war">安装包</a></p><br><p>1.2 打开安装包所在目录，运行命令 (前提是已经安装好jdk环境)</p><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">java -jar jenkins.war --httpPort=8080<br></code></pre></td></tr></table></figure><p><br>1.3 打开浏览器进入链接 <a href="http://localhost:8080/"><code>http://localhost:8080</code></a>.</p><br><p>1.4 填写初始密码</p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/unlock.png" alt="填写初始密码"></p><br><p>1.5 安装推荐的插件</p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/select.png" alt="安装推荐的插件"></p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/installing.png" alt="等待安装完成"></p><br><p>1.6 创建初始账户</p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220303172628857.png" alt="创建账户"></p><br><p>1.7 进入系统</p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220303173244049.png" alt="进入系统"></p><br><p>1.8 安装 <strong>Publish Over SSH</strong> 插件，在可选插件里搜索它并安装</p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220304161136721.png" alt="进入插件管理"></p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220304161410465.png" alt="安装后的状态"></p><br><p>1.9 配置服务器</p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220304161920823.png" alt="进入系统配置"></p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220304162330586.png" alt="拉到最下面，配置上图红字内容，保存"></p><br><ol><li>10 选择左侧栏的<strong>新建Item</strong>，然后输入任务名称，选择第一个<strong>Freestyle project</strong>，点击确定</li></ol><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220303174121621.png" alt="输入任务名称"></p><br><p>1.11 由于我是在自己的电脑上装的Jenkins，代码也在本地，所以下面的操作会有所不同，使用git管理代码的可以看参考文章</p><br><p>1.12 进入项目配置页面后，前面的内容都不用管，直接拖到<strong>构建</strong>这一栏</p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220304163450804.png" alt="这些都不用管"></p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220304164044168.png" alt="配置构建步骤"></p><br><p>1.13 点击<strong>增加构建步骤</strong>，由于我的电脑是Windows系统，所以选择<strong>执行Windows批处理命令</strong></p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220304165117558.png" alt="命令1"></p><br><p>然后再增加一个构建步骤，把打包好的jar包复制到Jenkins的工作目录（C:\Users\username\.jenkins\workspace\任务名称\）</p><p>ps: 尝试过将这个命令也放在上面，但是没有执行，所以只能单独拿出来</p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220304170535389.png" alt="命令2"></p><br><p>1.14 点击增加构建后操作，选择下图所示选项（用ssh把jar包发送到服务器），填写红字标注的内容</p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220304170920242.png" alt="选择SSH选项"></p><br><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220304171455765.png" alt="填写指引"></p><br><p>1.15 启动脚本 <strong>start.sh</strong> 内容如下，放在服务器的 /www/wwwroot/wx 目录下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#日期格式</span><br>date=<span class="hljs-string">&quot;[`date +&quot;</span>%Y-%m-%d_%H:%M:%S<span class="hljs-string">&quot;`]  &quot;</span><br><span class="hljs-comment">#script.log记录脚本执行日志</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$date</span><span class="hljs-string">&#x27;---------start.sh----------&#x27;</span> &gt; script.log<br><span class="hljs-comment">#先查一下是否有正在运行的employee服务，获取它的进程id</span><br>pid=`ps -ef |grep employee.jar|grep -v grep|awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$date</span><span class="hljs-string">&#x27;employee service pid:&#x27;</span><span class="hljs-variable">$pid</span> &gt;&gt; script.log<br><br><span class="hljs-comment">#如果进程id不为空，说明已经有服务在运行，先停掉</span><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$pid</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$date</span><span class="hljs-string">&quot;Stop service : employee.jar&quot;</span> &gt;&gt; script.log<br><span class="hljs-built_in">kill</span> -9 <span class="hljs-variable">$pid</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$date</span><span class="hljs-string">&#x27;Start service : employee.jar&#x27;</span> &gt;&gt; script.log<br><span class="hljs-comment">#启动服务，必须用jdk的全路径，后台运行服务，日志输出到employee.log</span><br>nohup /usr/<span class="hljs-built_in">local</span>/jdk1.8.0_321/bin/java -jar employee.jar &gt; employee.log &amp;<br><span class="hljs-comment">#再次获取服务进程id</span><br>pid=`ps -ef |grep employee.jar|grep -v grep|awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`<br><span class="hljs-comment">#如果进程id不为空，则服务启动成功</span><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$pid</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$date</span><span class="hljs-string">&#x27;Start service success! pid:&#x27;</span><span class="hljs-variable">$pid</span> &gt;&gt; script.log<br><span class="hljs-built_in">exit</span> 0<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$date</span><span class="hljs-string">&#x27;Start service fail!&#x27;</span> &gt;&gt; script.log<br><span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><br><p>1.16 配置完成，点击保存，回到首页，点击右边的按钮开始一次构建</p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220304173047698.png" alt="开始构建"></p><p><img src="/2022/03/03/Jenkins%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/image-20220304173350647.png" alt="查看构建输出的日志"></p><h1 id="2、参考文章"><a href="#2、参考文章" class="headerlink" title="2、参考文章"></a>2、参考文章</h1><p><a href="https://www.cnblogs.com/butingxue/p/14068409.html">Jenkins详细教程-jenkins安装与配置 - 不停学 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
      <tag>持续集成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Springboot项目里整合Redis</title>
    <link href="/2022/03/03/%E5%9C%A8Springboot%E9%A1%B9%E7%9B%AE%E9%87%8C%E6%95%B4%E5%90%88Redis/"/>
    <url>/2022/03/03/%E5%9C%A8Springboot%E9%A1%B9%E7%9B%AE%E9%87%8C%E6%95%B4%E5%90%88Redis/</url>
    
    <content type="html"><![CDATA[<p>基本上现在很多项目都会用到Redis，在项目里整合Redis也是非常简单，只须两步：</p><h1 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h1><p>首先在pom文件里引入Redis依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis依赖配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2、添加配置"><a href="#2、添加配置" class="headerlink" title="2、添加配置"></a>2、添加配置</h1><p>其次在yml文件里添加Redis所需的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># Redis服务器地址</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># Redis数据库索引（默认为0）</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span> <span class="hljs-comment"># Redis服务器连接端口</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span> <span class="hljs-comment"># Redis服务器连接密码（默认为空）</span><br>    <span class="hljs-attr">jedis:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span> <span class="hljs-comment"># 连接池最大连接数（使用负值表示没有限制）</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">-1ms</span> <span class="hljs-comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span> <span class="hljs-comment"># 连接池中的最大空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 连接池中的最小空闲连接</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-string">3000ms</span> <span class="hljs-comment"># 连接超时时间（毫秒）</span><br></code></pre></td></tr></table></figure><p>完。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven常用命令</title>
    <link href="/2022/03/03/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/03/03/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>Maven项目构建过程中，主要构建命令有几种：</p><p><img src="/2022/03/03/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20220303144102453.png" alt="idea里面的maven命令"></p><p>下面介绍一下每个命令的作用：</p><br><figure class="highlight armasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mvn</span> clean<br></code></pre></td></tr></table></figure><p> 清理，清理项目缓存输出，一般是target文件夹被删除；</p><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mvn</span> validate<br></code></pre></td></tr></table></figure><p> 验证，验证项目是正确的并且所有的信息是可用的；</p><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mvn</span> compile<br></code></pre></td></tr></table></figure><p> 编译，将java源文件编译成.class文件；</p><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mvn</span> test<br></code></pre></td></tr></table></figure><p> 测试，生成测试报告，运行test目录下的所有单元测试；</p><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">mvn <span class="hljs-class"><span class="hljs-keyword">package</span></span><br></code></pre></td></tr></table></figure><p> 打包，将项目打成jar、war或者pom；</p><br><p>PS：可以使用以下命令在打包时跳过测试</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">mvn package -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dmaven</span>.</span></span>test.skip=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p> 或者直接在pom文件里添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">skipTests</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">skipTests</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/03/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20220303145016033.png" alt="在pom里设置打包跳过测试"></p><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mvn</span> verify<br></code></pre></td></tr></table></figure><p>运行任何检查，验证包是否有效且达到质量标准。 </p><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mvn</span> install<br></code></pre></td></tr></table></figure><p> 安装，将打好的包复制到本地maven库，供其他项目依赖；</p><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mvn</span> site<br></code></pre></td></tr></table></figure><p>生成项目的站点文档</p><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mvn</span> deploy<br></code></pre></td></tr></table></figure><p>部署，将打好的包复制到本地maven库和远程maven库。</p><br><p>tips1：以树的结构展示项目中的依赖</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mvn</span> dependency:tree<br></code></pre></td></tr></table></figure><p>或者在idea里面点击这个图标</p><p><img src="/2022/03/03/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20220303145652976.png" alt="显示项目依赖"></p><br><p>tips2：打包的时候同时打包源码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span> <span class="hljs-comment">&lt;!-- 源代码使用jdk1.8支持的特性 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span> <span class="hljs-comment">&lt;!-- 使用jvm1.8编译目标代码 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">compilerArgs</span>&gt;</span> <span class="hljs-comment">&lt;!-- 传递参数 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span>&gt;</span>-parameters<span class="hljs-tag">&lt;/<span class="hljs-name">arg</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span>&gt;</span>-Xlint:unchecked<span class="hljs-tag">&lt;/<span class="hljs-name">arg</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span>&gt;</span>-Xlint:deprecation <span class="hljs-tag">&lt;/<span class="hljs-name">arg</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">compilerArgs</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 以下配置可以打包源码 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-source-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>attach-sources<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>verify<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>jar-no-fork<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云服务器初体验</title>
    <link href="/2022/01/24/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2022/01/24/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>最近突然开始关注起服务器相关的信息，看得心里痒痒的，想着自己买一个服务器来玩玩。然后偶然在网上看到腾讯云的服务器一年才38元，真香！</p><p><strong>就是这个</strong>&gt;&gt;&gt;  <a href="https://cloud.tencent.com/act/cps/redirect?redirect=1077&cps_key=972e542d7f6d5c5aeadde1633739f7dd&from=console"><strong>【腾讯云】热门云产品首单特惠秒杀，1核2G云服务器首年38元</strong></a></p><img src="/2022/01/24/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E4%BD%93%E9%AA%8C/image-20220125001725309.png" alt style="zoom:50%;"><p>虽然配置是最低的，但是用来部署博客，跑几个小应用，也足够了。</p><p>然后昨天我就把它买下来了，经过两天的折腾，终于把自己的东西弄上去了。</p><p>第一个搭建的是<a href="https://kodcloud.com/download/">kodbox（可道云）</a>，这是一个私人云盘，可以把文件/音乐/视频传上去，在浏览器直接预览/编辑/下载，这几个特点还是比较吸引我的。后面有空再出一个搭建教程，包括服务器（Linux）搭建，本地（Windows）搭建。</p><p>第二个搭建的是我的公众号的后端服务，这里面包括了一些springboot项目打包/运行、nginx配置、<a href="https://blog.csdn.net/pdsu161530247/article/details/81582980">服务器配置jdk环境</a>相关的知识，后面有空再详细说一下。我在公众号里弄了一个聊天机器人，大家可以去体验一下，微信公众号搜索 <strong>Zahi</strong> 并关注就好了。</p><p>第三个就是把我的博客部署到服务器上了，主要参考了这个博客 【<a href="https://blog.csdn.net/qq_35561857/article/details/81590953">带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器</a>】。不过由于域名没有备案，不能解析到自己的服务器上，所以现在的博客实际还是访问Github page。</p><p>以后会继续折腾这个服务器，把一些有趣或者有用的小玩意放上去~</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>服务器</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Hexo博客上添加Live2d动漫人物</title>
    <link href="/2022/01/21/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E6%B7%BB%E5%8A%A0Live2d%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/"/>
    <url>/2022/01/21/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E6%B7%BB%E5%8A%A0Live2d%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><p>想必大家经常能在一些博客的角落看到一个动漫人物（如下图右下角），并且可以用鼠标跟她进行互动，这个东西呢就叫做<strong>Live2d</strong>，今天就来说一下怎么在Hexo中添加Live2d人物。</p><span id="more"></span><p><img src="/2022/01/21/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E6%B7%BB%E5%8A%A0Live2d%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/image-20220121204439552.png"></p><h1 id="1、安装-hexo-helper-live2d-模块"><a href="#1、安装-hexo-helper-live2d-模块" class="headerlink" title="1、安装 hexo-helper-live2d 模块"></a>1、安装 hexo-helper-live2d 模块</h1><p>这个很简单，直接在你的博客根目录下执行</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">npm install --save hexo-helper-live2d<br></code></pre></td></tr></table></figure><p>项目地址：<a href="https://github.com/EYHN/hexo-helper-live2d">EYHN/hexo-helper-live2d: Add the Sseexxyyy live2d to your hexo! </a></p><h1 id="2、下载Live2d人物模型"><a href="#2、下载Live2d人物模型" class="headerlink" title="2、下载Live2d人物模型"></a>2、下载Live2d人物模型</h1><p>比如我要用上图这个小女孩的模型，执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install live2d-widget-model-shizuku<br></code></pre></td></tr></table></figure><p>其他更多模型看这里：<a href="https://github.com/xiazeyu/live2d-widget-models">xiazeyu/live2d-widget-models</a></p><p>选择自己喜欢的下载</p><h1 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h1><p>在博客根目录下的 <code>_config.yml</code> 里面添加如下配置：（注意use字段改为自己下载的模型）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span><br>  <span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span><br>  <span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span><br>  <span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-shizuku</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">150</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">300</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">react:</span><br>    <span class="hljs-attr">opacity:</span> <span class="hljs-number">0.7</span><br></code></pre></td></tr></table></figure><p>最后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br>hexo s<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Live2d</tag>
      
      <tag>动漫</tag>
      
      <tag>花里胡哨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>申请免费域名并绑定到Github Page</title>
    <link href="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/"/>
    <url>/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/</url>
    
    <content type="html"><![CDATA[<p>在Github Page上搭建完博客之后，发现博客的域名有点长，不是很满意，所以想着搞一个自己的域名。经过一番网上冲浪之后，发现可以在<a href="http://www.freenom.com/zh/index.html">Freenom</a>上白嫖一个免费的顶级域名，freenom 提供了tk、ml、ga、cf、gq这几个后缀的免费域名。下面主要介绍 freenom 免费域名的申请过程及设置域名解析。</p><span id="more"></span><h1 id="0、安装浏览器插件"><a href="#0、安装浏览器插件" class="headerlink" title="0、安装浏览器插件"></a>0、安装浏览器插件</h1><p>首先安装一个非常实用的浏览器插件，iGG谷歌学术助手（我的浏览器是Edge，其他浏览器同理）</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119171437974.png" alt="image-20220119171437974"></p><p>使用它可以访问Google、Gmail等服务，而且装上它之后访问freenom官网的速度快了很多，其他的功能大家就自己探索吧。</p><p>添加这个插件之后会提示用邮箱登录，用QQ邮箱直接登录就行。</p><h1 id="1、申请免费域名"><a href="#1、申请免费域名" class="headerlink" title="1、申请免费域名"></a>1、申请免费域名</h1><p>访问<a href="https://www.freenom.com/zh/index.html?lang=zh">Freenom</a>官网，输入自己想要的域名，点击检测可用性</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119172951872.png" alt="image-20220119172951872"></p><p>选择免费的，点击现在获取</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119173335712.png" alt="image-20220119173335712"></p><p>如果点击了之后显示不可用，可以直接带后缀搜索，这样会直接加入购物车</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119214116257.png" alt="image-20220119214116257"></p><p>到下一个页面，选择12个月</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119214342583.png" alt="image-20220119214342583"></p><p>点击Continue，进入如下页面</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119214500864.png" alt="image-20220119214500864"></p><p>如果有谷歌或Facebook账号可以直接登录，这里我选择输入邮箱</p><p>然后会收到一个邮件，点击邮件里面的连接，填写如下信息，重点：国家和省份要和IP地址的归属地一致，复制下方的IP（这是你的外网IP）到<a href="https://www.ip138.com/">这个网站</a>查询IP归属地</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119220118207.png" alt="image-20220119220118207"></p><p>填完之后点击Complete Order，出现如下页面，说明申请成功了。</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119220201679.png" alt="image-20220119220201679"></p><p>PS：如果这个页面有如下信息：<code>Attention! Some of your domains could not be registered because of a technical error. These domains have been cancelled</code> 说明域名注册失败，原因是国家/省份和IP地址归属地不匹配，到个人信息里面修改即可。</p><p>点击Services–My Domains查看自己的域名</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119221920491.png" alt="image-20220119221920491"></p><h1 id="2、DNS域名解析设置"><a href="#2、DNS域名解析设置" class="headerlink" title="2、DNS域名解析设置"></a>2、DNS域名解析设置</h1><p>点击Manage Domain</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119222418995.png" alt="image-20220119222418995"></p><p>选择Nameservers</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119222519130.png" alt="image-20220119222519130"></p><p>选择Use custom nameservers，填入下面两个地址，最后点击Change Nameservers</p><p><code>RAINFALL.DNSPOD.NET</code></p><p><code>SUN.DNSPOD.NET</code></p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119222730058.png" alt="image-20220119222730058"></p><p>上述操作的意思是，不使用freenom的默认DNS，而是授权给DNSpod来处理域名解析</p><p>进入<a href="https://www.dnspod.cn/login">DNSPOD</a>，直接微信扫码登录</p><p>点击左侧 我的域名，然后添加域名</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119223340835.png" alt="image-20220119223340835"></p><p>输入我们的域名后，点击确认</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119223523873.png" alt="image-20220119223523873"></p><p>点击这个域名</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119223623892.png" alt="image-20220119223623892"></p><p>添加记录</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119223712237.png" alt="image-20220119223712237"></p><p>填写如下内容，点击确认</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119224749272.png" alt="image-20220119224749272"></p><p>其中的IP地址来自  <code>ping 你的账号.github.io</code></p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119224925938.png" alt="image-20220119224925938"></p><p>最后到项目里 settings–&gt;Pages–&gt;Custom domain 输入你的域名保存就好啦。</p><p><img src="/2022/01/19/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0Github-Page/image-20220119224411849.png" alt="image-20220119224411849"></p><p>在浏览器输入你的域名，enjoy！</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>域名</tag>
      
      <tag>DNS</tag>
      
      <tag>Freenom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo版本升级教程</title>
    <link href="/2022/01/18/Hexo%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B/"/>
    <url>/2022/01/18/Hexo%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在重新搭建Hexo的时候，执行 <code>hexo d</code> 部署出现了以下错误</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html<br>TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object<br>    at copyFile (node:fs:2774:10)<br>    at tryCatcher (D:\workspace\hexo\myblog\node_modules\bluebird\js\release\util.js:16:23)<br></code></pre></td></tr></table></figure><p>经过一番百度得知是hexo版本与nodejs版本不匹配导致 <a href="https://hexo.io/zh-cn/docs/#Node-js-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6">Hexo–Node.js 版本限制</a></p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> hexo -v</span><br>hexo: 3.9.0<br>hexo-cli: 4.3.0<br>os: win32 10.0.22000<br>node: 16.13.2<br>v8: 9.4.146.24-node.14<br>uv: 1.42.0<br>zlib: 1.2.11<br>brotli: 1.0.9<br>ares: 1.18.1<br>modules: 93<br>nghttp2: 1.45.1<br>napi: 8<br>llhttp: 6.0.4<br>openssl: 1.1.1l+quic<br>cldr: 39.0<br>icu: 69.1<br>tz: 2021a<br>unicode: 13.0<br>ngtcp2: 0.1.0-DEV<br>nghttp3: 0.1.0-DEV<br></code></pre></td></tr></table></figure><p>（不知道为什么使用 <code>npm install -g hexo-cli</code> 下载的hexo版本这么旧）</p><p>解决方法有两个，一个是降级nodejs，另一个是升级hexo版本，我选择的是后者，下面是操作过程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">//以下指令均在博客目录下操作，先定位到博客目录<br>//查看当前版本，判断是否需要升级<br><span class="hljs-meta">&gt;</span><span class="bash"> hexo v</span><br><br>//安装npm-check，若已安装可以跳过<br><span class="hljs-meta">&gt;</span><span class="bash"> npm install -g npm-check</span><br><br>//检查系统插件是否需要升级<br><span class="hljs-meta">&gt;</span><span class="bash"> npm-check</span><br><br>//安装npm-upgrade，若已安装可以跳过<br><span class="hljs-meta">&gt;</span><span class="bash"> npm install -g npm-upgrade</span><br><br>//更新package.json<br><span class="hljs-meta">&gt;</span><span class="bash"> npm-upgrade</span><br><br>//更新全局插件<br><span class="hljs-meta">&gt;</span><span class="bash"> npm update -g</span><br><br>//更新系统插件<br><span class="hljs-meta">&gt;</span><span class="bash"> npm update --save</span><br><br>//再次查看版本，判断是否升级成功<br><span class="hljs-meta">&gt;</span><span class="bash"> hexo v</span><br></code></pre></td></tr></table></figure><p>至此，就升级完成了。</p><p>PS：在升级完成后，使用hexo时遇到一个warn警告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">WARN  Deprecated config detected: &quot;external_link&quot; with a Boolean value is deprecated. See https://hexo.io/docs/configuration for more details.<br></code></pre></td></tr></table></figure><p>解决方法：在 _config.yml 里面搜索 external_link</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">external_link: true # Open external links in new tab<br></code></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">external_link:<br>  enable: true # Open external links in new tab<br>  field: site # Apply to the whole site<br>  exclude: &#x27;&#x27; # Open external links in new tab<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo升级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建教程</title>
    <link href="/2022/01/18/Hexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <url>/2022/01/18/Hexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>时隔多年，我终于想起了曾经搭建过一个博客部署在github page上，这两年因为工作太忙没时间更新，现在有空了，打算重新捡回来继续更新，奈何搭建过程忘得差不多了，所以找了个教程，感觉写得挺不错的，分享一下。</p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程_Fangzh的技术博客-CSDN博客_hexo</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github ssh 配置</title>
    <link href="/2022/01/15/github%20ssh%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/01/15/github%20ssh%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p> 在本地推代码到github的时候，要先配置一下ssh</p> <span id="more"></span><h2 id="生成ssh-key"><a href="#生成ssh-key" class="headerlink" title="生成ssh key"></a>生成ssh key</h2><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br>ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;997798407@qq.com&quot;</span><br></code></pre></td></tr></table></figure><p>然后一路回车就行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat .ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>把key复制好</p><h2 id="在github配置ssh-key"><a href="#在github配置ssh-key" class="headerlink" title="在github配置ssh key"></a>在github配置ssh key</h2><p>进入这个页面: <a href="https://github.com/settings/keys">https://github.com/settings/keys</a></p><p>点击 <strong>new ssh key</strong>,把上面复制的粘贴保存</p><h2 id="设置username和email"><a href="#设置username和email" class="headerlink" title="设置username和email"></a>设置username和email</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;github的username&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;注册github的邮箱&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git多人协作情景下本地分支推送到远程分支</title>
    <link href="/2019/12/06/git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E6%83%85%E6%99%AF%E4%B8%8B%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/"/>
    <url>/2019/12/06/git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E6%83%85%E6%99%AF%E4%B8%8B%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</url>
    
    <content type="html"><![CDATA[<p> 场景：在公司开发，一般都是多人协作的情景，git上的分支也有master、ver、dev、Feature_1206_XXX……之类的，假设我把某个Feature分支拉到本地，修改并commit之后，另一个同事已经提交了几个commit并且push到了远程分支，这时我直接push是不行的，要先经过以下几个步骤：</p><span id="more"></span><p>第一步：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">add</span> XXX<br>git <span class="hljs-keyword">commit</span> -m XXX<br>#只提交自己的代码，有时候不得已要修改别人的代码，但又不想提交，那就不要<span class="hljs-keyword">add</span>进去<br></code></pre></td></tr></table></figure><p>第二步：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> stash   <br><span class="hljs-comment">#把没有commit的修改保存至堆栈中</span><br></code></pre></td></tr></table></figure><p>第三步：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git pull <span class="hljs-comment">--rebase</span><br><span class="hljs-comment">#从远程分支拉取最新的代码，并把你的commit放在最后面</span><br></code></pre></td></tr></table></figure><p>第四步：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">push</span><br><span class="hljs-meta">#推送你的代码到远程分支</span><br>git stash <span class="hljs-keyword">pop</span><br><span class="hljs-meta">#将当前stash中的内容弹出，把没有commit的modified文件恢复到工作区</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL知识点——LEFT JOIN</title>
    <link href="/2019/11/25/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94LEFT-JOIN/"/>
    <url>/2019/11/25/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94LEFT-JOIN/</url>
    
    <content type="html"><![CDATA[<p>left join on 即左连接，把left join左边的表的记录全部找出来，即使右边的表没有记录。</p><p>A LEFT JOIN B ON 条件表达式:</p><p>ON 条件用来决定如何从 B 表中检索数据行。</p><span id="more"></span><p>如果 B 表中没有任何一行数据匹配 ON 的条件,将会额外生成一行所有列为 NULL 的数据。</p><p>在匹配阶段 WHERE 子句的条件都不会被使用。仅在匹配阶段完成以后，WHERE 子句条件才会被使用。它将从匹配阶段产生的数据中检索过滤。</p><p>SELECT * FROM A LEFT JOIN B ON A.ID=B.ID WHERE B.OTHERKEY=XXXX<br>与<br>SELECT * FROM A LEFT JOIN B ON A.ID=B.ID AND B.OTHERKEY=XXXX<br>是不一样的</p><p>后者相当于（出来的结果一样）<br>SELECT * FROM A LEFT JOIN B ON A.ID=B.ID WHERE B.OTHERKEY=XXXX OR B.OTHERKEY IS NULL</p><p>进行左连接时，就有涉及到主表、辅表，这时主表条件写在WHERE之后，辅表条件写在ON后面！！！</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL知识点——时差函数</title>
    <link href="/2019/10/22/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E6%97%B6%E5%B7%AE%E5%87%BD%E6%95%B0/"/>
    <url>/2019/10/22/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E6%97%B6%E5%B7%AE%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>时间差函数TIMESTAMPDIFF、DATEDIFF的用法:</p><p>TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)</p><p>该函数能计算两个时间datetime_expr1（小）、datetime_expr2（大）的差，并按照指定的单位unit输出（单位可以是时/分/秒/日/年）。例：</p><span id="more"></span><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> TIMESTAMPDIFF(<span class="hljs-keyword">HOUR</span>,&quot;2019-10-21 11:16:00&quot;,CURTIME())<br># output: <span class="hljs-number">24</span><br><span class="hljs-keyword">select</span> TIMESTAMPDIFF(<span class="hljs-keyword">DAY</span>,&quot;2019-01-01&quot;,CURDATE())<br># output: <span class="hljs-number">294</span><br><span class="hljs-keyword">select</span> TIMESTAMPDIFF(<span class="hljs-keyword">YEAR</span>,&quot;1996-10-22&quot;,CURDATE())<br># output: <span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p>CURTIME()能获取当前时间，CURDATE()获取当前日期。</p><p>DATEDIFF(expr1,expr2)函数，返回值是相差的天数，不能定位到小时、分钟和秒。例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> DATEDIFF(CURDATE(),&quot;2020-01-01&quot;) <span class="hljs-keyword">as</span> &quot;距离下一个假期还有&quot;<br># output: <span class="hljs-number">-71</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot+Druid配置</title>
    <link href="/2019/10/21/Springboot-Druid%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/10/21/Springboot-Druid%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p> 最近在学习数据库连接池，了解到阿里开发的 <a href="https://github.com/alibaba/druid">druid</a> 非常强大，所以打算拿来练练手， 然而在配置时看了很多博文都配置不好，最后终于找到一篇有用的，原文地址 <a href="https://segmentfault.com/a/1190000019741217?utm_source=tag-newest">https://segmentfault.com/a/1190000019741217?utm_source=tag-newest</a></p><p>废话少说，下面开搞：</p><span id="more"></span><br><p>1、pom</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><br><p>2、application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>  <span class="hljs-comment">#数据库账号密码记得修改为自己的</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/databasename?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br>    <span class="hljs-comment">#上面的databasename记得改为自己的</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>    <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">minIdle:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span><br>    <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>    <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall,log4j</span>  <span class="hljs-comment">#log4j应该可以去掉，上面的依赖也去掉</span><br>    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br></code></pre></td></tr></table></figure><br><p>3、创建一个DruidConfig类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;<br><span class="hljs-keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;<br><span class="hljs-keyword">import</span> com.alibaba.druid.support.http.WebStatFilter;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;<br>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druid</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();<br>    &#125;<br>    <span class="hljs-comment">//配置Druid的监控</span><br>    <span class="hljs-comment">//1. 配置一个管理后台的servlet</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">statViewServlet</span><span class="hljs-params">()</span></span>&#123;<br>        ServletRegistrationBean bean =  <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> StatViewServlet(),<span class="hljs-string">&quot;/druid/*&quot;</span>);<br>        Map&lt;String,String&gt; initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        initParams.put(<span class="hljs-string">&quot;loginUsername&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<span class="hljs-comment">//账号</span><br>        initParams.put(<span class="hljs-string">&quot;loginPassword&quot;</span>,<span class="hljs-string">&quot;12345&quot;</span>);<span class="hljs-comment">//密码</span><br>        initParams.put(<span class="hljs-string">&quot;allow&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//默认允许所有</span><br>        initParams.put(<span class="hljs-string">&quot;deny&quot;</span>,<span class="hljs-string">&quot;192.168.123.22&quot;</span>);<span class="hljs-comment">//不允许的黑名单ip</span><br>        bean.setInitParameters(initParams);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-comment">// 2. 配置一个监控的filter</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">webStatFilter</span><span class="hljs-params">()</span></span>&#123;<br>        FilterRegistrationBean bean = <span class="hljs-keyword">new</span> FilterRegistrationBean();<br>        bean.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());<br>        Map&lt;String,String&gt; initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        initParams.put(<span class="hljs-string">&quot;exclusions&quot;</span>,<span class="hljs-string">&quot;*.js,*.css,/druid/*&quot;</span>);<br>        bean.setInitParameters(initParams);<br>        bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">&quot;/*&quot;</span>));<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>4、运行项目，打开网址<a href="http://localhost:8080/druid/">http://localhost:8080/druid/</a></p><br><p>5、下面还需要继续整合mybatis来实现对数据库的增删改查操作，请看下一篇文章：<a href="/2022/03/06/Springboot%E6%95%B4%E5%90%88mybatis/">Springboot整合Mybatis</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>Java</tag>
      
      <tag>Druid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读取yml文件时遇到的坑</title>
    <link href="/2019/10/19/%E8%AF%BB%E5%8F%96yml%E6%96%87%E4%BB%B6%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <url>/2019/10/19/%E8%AF%BB%E5%8F%96yml%E6%96%87%E4%BB%B6%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>1、在测试类里使用@Value(“${server.port}”)获取端口返回的值是-1，解决方法：在@SpringBootTest注解后面加上如下属性：</p><p>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)</p><p>原理：</p><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.context</span>.SpringBootContextLoader＃getInlinedProperties<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> String[] getInlinedProperties(MergedContextConfiguration config) &#123;<br>    ArrayList&lt;String&gt; properties = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-comment">// JMX bean names will clash if the same bean is used in multiple contexts</span><br>    disableJmx(properties);<br>    properties.addAll(Arrays.asList(config.getPropertySourceProperties()));<br>    <span class="hljs-keyword">if</span> (!isEmbeddedWebEnvironment(config) &amp;&amp; !hasCustomServerPort(properties)) &#123;<br>        properties.add(<span class="hljs-string">&quot;server.port=-1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> properties.toArray(<span class="hljs-keyword">new</span> String[properties.size()]);<br>&#125;<br></code></pre></td></tr></table></figure><p>2、使用@ConfigurationProperties方式读取yml文件中的属性时，prefix的值不能有大写，如：prefix = “myProps”， 这样写会报错，所以yml文件中的key一定要是小写。</p><p>PS：我使用的是springboot 2.X版本，springboot 1.5以下版本貌似不存在此类问题！</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL知识点——日期函数</title>
    <link href="/2019/10/18/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E6%97%A5%E6%9C%9F/"/>
    <url>/2019/10/18/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E6%97%A5%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>DATE_FORMAT(date,format)， 用来转换日期格式。<em>date</em> 参数是合法的日期。<em>format</em> 规定日期/时间的输出格式。</p><span id="more"></span><table><thead><tr><th align="left">格式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">%a</td><td align="left">缩写星期名</td></tr><tr><td align="left">%b</td><td align="left">缩写月名</td></tr><tr><td align="left">%c</td><td align="left">月，数值</td></tr><tr><td align="left">%D</td><td align="left">带有英文前缀的月中的天</td></tr><tr><td align="left">%d</td><td align="left">月的天，数值(00-31)</td></tr><tr><td align="left">%e</td><td align="left">月的天，数值(0-31)</td></tr><tr><td align="left">%f</td><td align="left">微秒</td></tr><tr><td align="left">%H</td><td align="left">小时 (00-23)</td></tr><tr><td align="left">%h</td><td align="left">小时 (01-12)</td></tr><tr><td align="left">%I</td><td align="left">小时 (01-12)</td></tr><tr><td align="left">%i</td><td align="left">分钟，数值(00-59)</td></tr><tr><td align="left">%j</td><td align="left">年的天 (001-366)</td></tr><tr><td align="left">%k</td><td align="left">小时 (0-23)</td></tr><tr><td align="left">%l</td><td align="left">小时 (1-12)</td></tr><tr><td align="left">%M</td><td align="left">月名</td></tr><tr><td align="left">%m</td><td align="left">月，数值(00-12)</td></tr><tr><td align="left">%p</td><td align="left">AM 或 PM</td></tr><tr><td align="left">%r</td><td align="left">时间，12-小时（hh:mm:ss AM 或 PM）</td></tr><tr><td align="left">%S</td><td align="left">秒(00-59)</td></tr><tr><td align="left">%s</td><td align="left">秒(00-59)</td></tr><tr><td align="left">%T</td><td align="left">时间, 24-小时 (hh:mm:ss)</td></tr><tr><td align="left">%U</td><td align="left">周 (00-53) 星期日是一周的第一天</td></tr><tr><td align="left">%u</td><td align="left">周 (00-53) 星期一是一周的第一天</td></tr><tr><td align="left">%V</td><td align="left">周 (01-53) 星期日是一周的第一天，与 %X 使用</td></tr><tr><td align="left">%v</td><td align="left">周 (01-53) 星期一是一周的第一天，与 %x 使用</td></tr><tr><td align="left">%W</td><td align="left">星期名</td></tr><tr><td align="left">%w</td><td align="left">周的天 （0=星期日, 6=星期六）</td></tr><tr><td align="left">%X</td><td align="left">年，其中的星期日是周的第一天，4 位，与 %V 使用</td></tr><tr><td align="left">%x</td><td align="left">年，其中的星期一是周的第一天，4 位，与 %v 使用</td></tr><tr><td align="left">%Y</td><td align="left">年，4 位</td></tr><tr><td align="left">%y</td><td align="left">年，2 位</td></tr></tbody></table><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATE_FORMAT(NOW(),<span class="hljs-string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span>)<br>#Output:  <span class="hljs-number">2019</span><span class="hljs-number">-10</span><span class="hljs-number">-18</span> <span class="hljs-number">15</span>:<span class="hljs-number">36</span>:<span class="hljs-number">06</span><br></code></pre></td></tr></table></figure><p>DATE_ADD(date,INTERVAL expr unit)，用来对日期进行计算，date参数是被计算的时间，expr是一个数值，可以是正的或负的，正的向后计算，负的向前计算，unit是单位。例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATE_ADD(NOW(),<span class="hljs-type">INTERVAL</span> <span class="hljs-number">-8</span> <span class="hljs-keyword">HOUR</span>), DATE_ADD(NOW(),<span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DAY</span>)<br>#Output： <span class="hljs-number">2019</span><span class="hljs-number">-10</span><span class="hljs-number">-18</span> <span class="hljs-number">07</span>:<span class="hljs-number">39</span>:<span class="hljs-number">21</span><span class="hljs-number">2019</span><span class="hljs-number">-10</span><span class="hljs-number">-19</span> <span class="hljs-number">15</span>:<span class="hljs-number">39</span>:<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><p>NOW() 可以获取当前时间，注意有些数据库获取的时间可能实际时间不同，那是因为它所设置的时区不是我们所在的时区。要更改时区的话可以这样做：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> time_zone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;+8:00&#x27;</span>;    #设置时区更改为东八区<br>flush privileges;   #刷新权限<br></code></pre></td></tr></table></figure><p>然后重启数据库就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven的settings.xml和pom.xml配置</title>
    <link href="/2019/10/17/maven%E7%9A%84settings-xml%E5%92%8Cpom-xml%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/10/17/maven%E7%9A%84settings-xml%E5%92%8Cpom-xml%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>  Maven的下载安装非常简单，直接到官网下载解压即可。配置环境变量不是必须的。顺便一提，Eclipse和Idea都自带了maven，所以你甚至不用下载maven。</p><p>下面重点讲一下settings.xml和pom.xml的配置。</p><span id="more"></span><p>Maven默认的settings.xml文件的路径是\apache-maven-3.6.2\conf\settings.xml。</p><p>settings.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">                          https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--该标签是用来设置本地仓库路径的，默认值是</span><br><span class="hljs-comment">&lt;localRepository&gt; $&#123;user.home&#125;/.m2/repository &lt;/localRepository&gt;</span><br><span class="hljs-comment">为了方便查看，可以设置成自己的目录，如：</span><br><span class="hljs-comment">&lt;localRepository&gt; D:/maven/repository &lt;/localRepository&gt;--&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">interactiveMode</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">interactiveMode</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--该标签表示maven是否需要和用户交互以获得输入，</span><br><span class="hljs-comment">它的值为true（默认）或false，在官方给的settings中，</span><br><span class="hljs-comment">该便签默认是被注释掉的，如果你不需要可以保持注释--&gt;</span><br>    <br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">offline</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">offline</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--该标签表示在Maven进行项目编译和部署等操作时是否允许</span><br><span class="hljs-comment">Maven进行联网来下载所需要的信息。如果构建系统需要在离线</span><br><span class="hljs-comment">模式下运行，则为true，默认为false。官方setting里是默认注释掉的--&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroups</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroups</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--该标签下面可以定义一系列的pluginGroup元素，示例：</span><br><span class="hljs-comment">&lt;pluginGroup&gt;org.codehaus.mojo&lt;/pluginGroup&gt;</span><br><span class="hljs-comment">&lt;pluginGroup&gt;org.apache.maven.plugins&lt;/pluginGroup&gt;</span><br><span class="hljs-comment">表示当通过plugin的前缀来解析plugin的时候到哪里寻找。</span><br><span class="hljs-comment">pluginGroup元素指定的是plugin的groupId。--&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--一般，仓库的下载和部署是在pom.xml文件中的 repositories 和</span><br><span class="hljs-comment"> distributionManagement 元素中定义的。然而，一般类似用户名、</span><br><span class="hljs-comment">密码（有些仓库访问是需要安全认证的）等信息不应该在pom.xml文件中</span><br><span class="hljs-comment">配置，这些信息可以配置在 settings.xml 中。示例：</span><br><span class="hljs-comment">&lt;server&gt;</span><br><span class="hljs-comment">          &lt;id&gt; server_id &lt;/id&gt;</span><br><span class="hljs-comment">          &lt;username&gt; my_name &lt;/username&gt;</span><br><span class="hljs-comment">          &lt;password&gt; my_password &lt;/password&gt;</span><br><span class="hljs-comment">    &lt;/server&gt;                  --&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--该标签用于定义一系列的远程仓库的镜像。示例：</span><br><span class="hljs-comment">        &lt;mirror&gt;</span><br><span class="hljs-comment">            &lt;id&gt;mirrorId&lt;/id&gt;</span><br><span class="hljs-comment">            &lt;name&gt;mirrorName&lt;/name&gt;</span><br><span class="hljs-comment">            &lt;url&gt;http://downloads.planetmirror.com/pub/maven2&lt;/url&gt;</span><br><span class="hljs-comment">            &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span><br><span class="hljs-comment">        &lt;/mirror&gt;--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">proxies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">proxies</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--该标签用来配置不同的代理。示例：</span><br><span class="hljs-comment">&lt;proxy&gt;</span><br><span class="hljs-comment">              &lt;id&gt;optional&lt;/id&gt;</span><br><span class="hljs-comment">              &lt;active&gt;true&lt;/active&gt;</span><br><span class="hljs-comment">              &lt;protocol&gt;http&lt;/protocol&gt;</span><br><span class="hljs-comment">              &lt;username&gt;proxyuser&lt;/username&gt;</span><br><span class="hljs-comment">              &lt;password&gt;proxypass&lt;/password&gt;</span><br><span class="hljs-comment">              &lt;host&gt;proxy.host.net&lt;/host&gt;</span><br><span class="hljs-comment">              &lt;port&gt;80&lt;/port&gt;</span><br><span class="hljs-comment">              &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;</span><br><span class="hljs-comment">    &lt;/proxy&gt;--&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--该标签根据环境参数来调整构建配置的列表。</span><br><span class="hljs-comment">settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。</span><br><span class="hljs-comment">它包含了id、activation、repositories、pluginRepositories和 properties元素。这里的profile元素只包含这五个子元素是因为这里只</span><br><span class="hljs-comment">关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单</span><br><span class="hljs-comment">独的项目对象模型设置。如果一个settings.xml中的profile被激活，它</span><br><span class="hljs-comment">的值会覆盖任何其它定义在pom.xml中带有相同id的profile。当所有的约</span><br><span class="hljs-comment">束条件都满足的时候就会激活这个profile。示例：</span><br><span class="hljs-comment">        &lt;profiles&gt;</span><br><span class="hljs-comment">            &lt;profile&gt;</span><br><span class="hljs-comment">                &lt;id&gt;test&lt;/id&gt;     </span><br><span class="hljs-comment">                &lt;activation&gt;</span><br><span class="hljs-comment">                    &lt;activeByDefault&gt;false&lt;/activeByDefault&gt;</span><br><span class="hljs-comment">                    &lt;jdk&gt;1.6&lt;/jdk&gt;</span><br><span class="hljs-comment">                    &lt;os&gt;</span><br><span class="hljs-comment">                        &lt;name&gt;Windows 7&lt;/name&gt;</span><br><span class="hljs-comment">                        &lt;family&gt;Windows&lt;/family&gt;</span><br><span class="hljs-comment">                        &lt;arch&gt;x86&lt;/arch&gt;</span><br><span class="hljs-comment">                        &lt;version&gt;5.1.2600&lt;/version&gt;</span><br><span class="hljs-comment">                    &lt;/os&gt;</span><br><span class="hljs-comment">                    &lt;property&gt;</span><br><span class="hljs-comment">                        &lt;name&gt;mavenVersion&lt;/name&gt;</span><br><span class="hljs-comment">                        &lt;value&gt;2.0.3&lt;/value&gt;</span><br><span class="hljs-comment">                    &lt;/property&gt;</span><br><span class="hljs-comment">                    &lt;file&gt;</span><br><span class="hljs-comment">                        &lt;exists&gt;$&#123;basedir&#125;/file2.properties&lt;/exists&gt;</span><br><span class="hljs-comment">                        &lt;missing&gt;$&#123;basedir&#125;/file1.properties&lt;/missing&gt;</span><br><span class="hljs-comment">                    &lt;/file&gt;</span><br><span class="hljs-comment">                &lt;/activation&gt;</span><br><span class="hljs-comment">                &lt;properties /&gt;</span><br><span class="hljs-comment">                &lt;repositories /&gt;</span><br><span class="hljs-comment">                &lt;pluginRepositories /&gt;</span><br><span class="hljs-comment">              ...</span><br><span class="hljs-comment">            &lt;/profile&gt;</span><br><span class="hljs-comment">        &lt;/profiles&gt; --&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">activeProfiles</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--该标签手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。示例：</span><br><span class="hljs-comment">        &lt;activeProfiles&gt;</span><br><span class="hljs-comment">            &lt;activeProfile&gt;env-test&lt;/activeProfile&gt;</span><br><span class="hljs-comment">          &lt;/activeProfiles&gt;--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p>pom.xml是一个maven项目用来指定依赖的文件，被指定的依赖库会自动导入到项目中，省去了一个个库下载然后导入的麻烦。pom所有属性详解如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 父项目的坐标 . 如果项目中没有规定某个元素的值 , 那么父项目中的对应值即为项目的默认值 .  坐标包括group ID , artifact ID和 version .  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>com.xbz<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-comment">&lt;!-- 被继承的父项目的构件标识符 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-comment">&lt;!-- 被继承的父项目的全球唯一标识符 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!-- 被继承的父项目的版本 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span><span class="hljs-comment">&lt;!--  父项目的pom.xml文件的相对路径 . 相对路径允许你选择一个不同的路径 . 默认值是../pom.xml . Maven首先在构建当前项目的地方寻找父项 目的pom , 其次在文件系统的这个位置（relativePath位置） , 然后在本地仓库 , 最后在远程仓库寻找父项目的pom .  --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><span class="hljs-comment">&lt;!-- 声明项目描述符遵循哪一个POM模型版本 . 模型本身的版本很少改变 , 虽然如此 , 但它仍然是必不可少的 , 这是为了当Maven引入了新的特性或者其他模型变更的时候 , 确保稳定性 .  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>asia.banseon<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目的全球唯一标识符 , 通常使用全限定的包名区分该项目和其他项目 . 并且构建时生成的路径也是由此生成 ,  如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>banseon-maven2<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-comment">&lt;!--  构件的标识符 , 它和group ID一起唯一标识一个构件 . 换句话说 , 你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下 , artifact ID也必须是唯一的 . 构件是项目产生的或使用的一个东西 , Maven为项目产生的构件包括：JARs , 源 码 , 二进制发布和WARs等 .  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目产生的构件类型 , 例如jar, war, ear, pom . 插件可以创建他们自己的构件类型 , 所以前面列的不是全部构件类型 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目当前版本 , 格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>banseon-maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目的名称, Maven产生的文档用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目主页的URL, Maven产生的文档用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>A maven project to study maven.<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><span class="hljs-comment">&lt;!--  项目的详细描述, Maven 产生的文档用 .   当这个元素能够用HTML格式描述时（例如 , CDATA中的文本会被解析器忽略 , 就可以包含HTML标 签） ,  不鼓励使用纯文本描述 . 如果你需要修改产生的web站点的索引页面 , 你应该修改你自己的索引页文件 , 而不是调整这里的文档 .  --&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 描述了这个项目构建环境中的前提条件 .  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prerequisites</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven</span>&gt;</span>2.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">maven</span>&gt;</span><span class="hljs-comment">&lt;!-- 构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prerequisites</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL , 本例为 jira --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">issueManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">system</span>&gt;</span>jira<span class="hljs-tag">&lt;/<span class="hljs-name">system</span>&gt;</span><span class="hljs-comment">&lt;!-- 问题管理系统（例如jira）的名字 ,  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://my.jira.com/banseon<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-comment">&lt;!-- 该项目使用的问题管理系统的URL --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">issueManagement</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 项目持续集成信息 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ciManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">system</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">system</span>&gt;</span><span class="hljs-comment">&lt;!-- 持续集成系统的名字 , 例如continuum --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-comment">&lt;!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话） .  --&gt;</span><br> <br>        <span class="hljs-comment">&lt;!-- 构建完成时 , 需要通知的开发者/用户的配置项 . 包括被通知者信息和通知条件（错误 , 失败 , 成功 , 警告） --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">notifiers</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 配置一种方式 , 当构建中断时 , 以该方式通知用户/开发者 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">notifier</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><span class="hljs-comment">&lt;!-- 传送通知的途径 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">sendOnError</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sendOnError</span>&gt;</span><span class="hljs-comment">&lt;!-- 发生错误时是否通知 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">sendOnFailure</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sendOnFailure</span>&gt;</span><span class="hljs-comment">&lt;!-- 构建失败时是否通知 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">sendOnSuccess</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sendOnSuccess</span>&gt;</span><span class="hljs-comment">&lt;!-- 构建成功时是否通知 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">sendOnWarning</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sendOnWarning</span>&gt;</span><span class="hljs-comment">&lt;!-- 发生警告时是否通知 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span><span class="hljs-comment">&lt;!-- 不赞成使用 . 通知发送到哪里 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-comment">&lt;!-- 扩展配置项 --&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">notifier</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">notifiers</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ciManagement</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">inceptionYear</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">inceptionYear</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目创建年份 , 4位数字 . 当产生版权信息时需要使用这个值 .  --&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 项目相关邮件列表信息 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mailingLists</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 该元素描述了项目相关的所有邮件列表 . 自动产生的网站引用这些信息 .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mailingList</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>XMail<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-comment">&lt;!-- 邮件的名称 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">post</span>&gt;</span>xingxbz@163.com<span class="hljs-tag">&lt;/<span class="hljs-name">post</span>&gt;</span><span class="hljs-comment">&lt;!-- 发送邮件的地址或链接 , 如果是邮件地址 , 创建文档时 , mailto: 链接会被自动创建 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">subscribe</span>&gt;</span>xingxbz@163.com<span class="hljs-tag">&lt;/<span class="hljs-name">subscribe</span>&gt;</span><span class="hljs-comment">&lt;!-- 订阅邮件的地址或链接 , 如果是邮件地址 , 创建文档时 , mailto: 链接会被自动创建 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">unsubscribe</span>&gt;</span>xingxbz@163.com<span class="hljs-tag">&lt;/<span class="hljs-name">unsubscribe</span>&gt;</span><span class="hljs-comment">&lt;!-- 取消订阅邮件的地址或链接 , 如果是邮件地址 , 创建文档时 , mailto: 链接会被自动创建 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span>http:/xingmail.com/demo/mail/<span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span><span class="hljs-comment">&lt;!-- 你可以浏览邮件信息的URL --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">mailingList</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mailingLists</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 项目开发者列表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">developers</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 某个项目开发者的信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">developer</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>DEV 001<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-comment">&lt;!-- SCM里项目开发者的唯一标识符 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Xingbz<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目开发者的全名 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>xingxbz@163.com<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目开发者的email --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://blog.csdn.net/xingbaozhen1210<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目开发者的主页的URL --&gt;</span><br> <br>            <span class="hljs-comment">&lt;!-- 项目开发者在项目中扮演的角色 , 角色元素描述了各种角色 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">roles</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">role</span>&gt;</span>Manager<span class="hljs-tag">&lt;/<span class="hljs-name">role</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">role</span>&gt;</span>Test<span class="hljs-tag">&lt;/<span class="hljs-name">role</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">role</span>&gt;</span>Dev<span class="hljs-tag">&lt;/<span class="hljs-name">role</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">roles</span>&gt;</span><br> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">organization</span>&gt;</span>xbz<span class="hljs-tag">&lt;/<span class="hljs-name">organization</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目开发者所属组织 --&gt;</span><br> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">organizationUrl</span>&gt;</span>https://blog.csdn.net/xingbaozhen1210<span class="hljs-tag">&lt;/<span class="hljs-name">organizationUrl</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目开发者所属组织的URL --&gt;</span><br> <br>            <span class="hljs-comment">&lt;!-- 项目开发者属性 , 如即时消息如何处理等 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dept</span>&gt;</span>No<span class="hljs-tag">&lt;/<span class="hljs-name">dept</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">timezone</span>&gt;</span>+8<span class="hljs-tag">&lt;/<span class="hljs-name">timezone</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目开发者所在时区 ,  -11到12范围内的整数 .  --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">developer</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">developers</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 项目的其他贡献者列表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">contributors</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 项目的其他贡献者 . 参见developers/developer元素 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">contributor</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">organization</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">organization</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">organizationUrl</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">organizationUrl</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">roles</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">roles</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">timezone</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">timezone</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">contributor</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">contributors</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 该元素描述了项目所有License列表 .  应该只列出该项目的license列表 , 不要列出依赖项目的 license列表 . 如果列出多个license , 用户可以选择它们中的一个而不是接受所有license .  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">licenses</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 描述了项目的license , 用于生成项目的web站点的license页面 , 其他一些报表和validation也会用到该元素 .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Xbz Projet<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-comment">&lt;!-- license用于法律上的名称 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://blog.csdn.net/xingbaozhen1210<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-comment">&lt;!-- 官方的license正文页面的URL --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">distribution</span>&gt;</span>repo<span class="hljs-tag">&lt;/<span class="hljs-name">distribution</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目分发的主要方式： repo , 可以从Maven库下载 manual ,  用户必须手动下载和安装依赖 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">comments</span>&gt;</span>ABCDEFG...<span class="hljs-tag">&lt;/<span class="hljs-name">comments</span>&gt;</span><span class="hljs-comment">&lt;!-- 关于license的补充信息 --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">licenses</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- SCM(Source Control Management)标签允许你配置你的代码库 , 供Maven web站点和其它插件使用 .  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scm</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">connection</span>&gt;</span>scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">connection</span>&gt;</span><span class="hljs-comment">&lt;!-- SCM的URL,该URL描述了版本库和如何连接到版本库 . 欲知详情 , 请看SCMs提供的URL格式和列表 . 该连接只读 .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">developerConnection</span>&gt;</span>scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk<span class="hljs-tag">&lt;/<span class="hljs-name">developerConnection</span>&gt;</span><span class="hljs-comment">&lt;!-- 给开发者使用的 , 类似connection元素 . 即该连接不仅仅只读 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tag</span>&gt;</span><span class="hljs-comment">&lt;!-- 当前代码的标签 , 在开发阶段默认为HEAD --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://svn.baidu.com/banseon<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-comment">&lt;!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL .  --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">scm</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 描述项目所属组织的各种属性 . Maven产生的文档用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">organization</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-comment">&lt;!-- 组织的全名 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-comment">&lt;!-- 组织主页的URL --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">organization</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 构建项目需要的信息 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sourceDirectory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sourceDirectory</span>&gt;</span><span class="hljs-comment">&lt;!-- 该元素设置了项目源码目录 , 当构建项目的时候 , 构建系统会编译目录里的源码 . 该路径是相对于pom.xml的相对路径 .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scriptSourceDirectory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">scriptSourceDirectory</span>&gt;</span><span class="hljs-comment">&lt;!-- 该元素设置了项目脚本源码目录 , 该目录和源码目录不同：绝大多数情况下 , 该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的 , 而不是被编译的) .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">testSourceDirectory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">testSourceDirectory</span>&gt;</span><span class="hljs-comment">&lt;!-- 该元素设置了项目单元测试使用的源码目录 , 当测试项目的时候 , 构建系统会编译目录里的源码 . 该路径是相对于pom.xml的相对路径 .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><span class="hljs-comment">&lt;!-- 被编译过的应用程序class文件存放的目录 .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">testOutputDirectory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">testOutputDirectory</span>&gt;</span><span class="hljs-comment">&lt;!-- 被编译过的测试class文件存放的目录 .  --&gt;</span><br> <br>        <span class="hljs-comment">&lt;!-- 使用来自该项目的一系列构建扩展 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 描述使用到的构建扩展 .  --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-comment">&lt;!-- 构建扩展的groupId --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-comment">&lt;!-- 构建扩展的artifactId --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!-- 构建扩展的版本 --&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">defaultGoal</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">defaultGoal</span>&gt;</span><span class="hljs-comment">&lt;!-- 当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span><br> <br>        <span class="hljs-comment">&lt;!-- 这个元素描述了项目相关的所有资源路径列表 , 例如和项目相关的属性文件 , 这些资源被包含在最终的打包文件里 .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span><span class="hljs-comment">&lt;!--  描述了资源的目标路径 . 该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;） . 举个例 子 , 如果你想资源在特定的包里(org.apache.maven.messages) , 你就必须该元素设置为org/apache/maven /messages . 然而 , 如果你只是想把资源放到源码目录结构里 , 就不需要该配置 .  --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><span class="hljs-comment">&lt;!-- 是否使用参数值代替参数名 . 参数值取自properties元素或者文件里配置的属性 , 文件在filters元素里列出 .  --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><span class="hljs-comment">&lt;!-- 描述存放资源的目录 , 该路径相对POM路径 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><span class="hljs-comment">&lt;!-- 包含的模式列表 , 例如**/*.xml. --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><span class="hljs-comment">&lt;!-- 排除的模式列表 , 例如**/*.xml --&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br> <br>        <span class="hljs-comment">&lt;!-- 这个元素描述了单元测试相关的所有资源路径 , 例如和单元测试相关的属性文件 .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">testResources</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 这个元素描述了测试相关的所有资源路径 , 参见build/resources/resource元素的说明 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">testResource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">testResource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">testResources</span>&gt;</span><br> <br> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><span class="hljs-comment">&lt;!-- 构建产生的所有文件存放的目录 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><span class="hljs-comment">&lt;!-- 产生的构件的文件名 , 默认值是$&#123;artifactId&#125;-$&#123;version&#125; .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filters</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filters</span>&gt;</span><span class="hljs-comment">&lt;!-- 当filtering开关打开时 , 使用到的过滤器属性文件列表 --&gt;</span><br> <br>        <span class="hljs-comment">&lt;!-- 子项目可以引用的默认插件信息 . 该插件配置项直到被引用时才会被解析或绑定到生命周期 . 给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 使用的插件列表  .  --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- plugin元素包含描述插件所需要的信息 .  --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-comment">&lt;!-- 插件在仓库里的group ID --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-comment">&lt;!-- 插件在仓库里的artifact ID --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!-- 被使用的插件的版本（或版本范围） --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span><span class="hljs-comment">&lt;!-- 是否从该插件下载Maven扩展（例如打包和类型处理器） , 由于性能原因 , 只有在真需要下载时 , 该元素才被设置成enabled .  --&gt;</span><br> <br>                    <span class="hljs-comment">&lt;!-- 在构建生命周期中执行一组目标的配置 . 每个目标可能有不同的配置 .  --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!-- execution元素包含了插件执行需要的信息 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-comment">&lt;!-- 执行目标的标识符 , 用于标识构建过程中的目标 , 或者匹配继承过程中需要合并的执行目标 --&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><span class="hljs-comment">&lt;!-- 绑定了目标的构建生命周期阶段 , 如果省略 , 目标会被绑定到源数据里配置的默认阶段 --&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><span class="hljs-comment">&lt;!-- 配置的执行目标 --&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-comment">&lt;!-- 配置是否被传播到子POM --&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-comment">&lt;!-- 作为DOM对象的配置 --&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!-- 项目引入插件所需要的额外依赖 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                            ......<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br> <br>                    <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-comment">&lt;!-- 任何配置是否被传播到子项目 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-comment">&lt;!-- 作为DOM对象的配置 --&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br> <br>        <span class="hljs-comment">&lt;!-- 使用的插件列表 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">inherited</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                        ......<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">inherited</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 在列的项目构建profile , 如果被激活 , 会修改构建处理 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 根据环境参数或命令行参数激活某个构建处理 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-comment">&lt;!-- 构建配置的唯一标识符 . 即用于命令行激活 , 也用于在继承时合并具有相同标识符的profile .  --&gt;</span><br>            <span class="hljs-comment">&lt;!-- 自动触发profile的条件逻辑 . Activation是profile的开启钥匙 . profile的力量来自于它</span><br><span class="hljs-comment">            能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定 . activation元素并不是激活profile的唯一方式 .  --&gt;</span><br> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><span class="hljs-comment">&lt;!-- profile默认是否激活的标志 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><span class="hljs-comment">&lt;!-- 当匹配的jdk被检测到 , profile被激活 . 例如 , 1.4激活JDK1.4 , 1.4.0_2 , 而!1.4激活所有版本不是以1.4开头的JDK .  --&gt;</span><br> <br>                <span class="hljs-comment">&lt;!-- 当匹配的操作系统属性被检测到 , profile被激活 . os元素可以定义一些操作系统相关的属性 .  --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">os</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Windows 7<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-comment">&lt;!-- 激活profile的操作系统的名字 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Windows<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><span class="hljs-comment">&lt;!-- 激活profile的操作系统所属家族(如 &#x27;windows&#x27;) --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">arch</span>&gt;</span>x64<span class="hljs-tag">&lt;/<span class="hljs-name">arch</span>&gt;</span><span class="hljs-comment">&lt;!-- 激活profile的操作系统体系结构  --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.2.3580<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!-- 激活profile的操作系统版本 --&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">os</span>&gt;</span><br> <br>                <span class="hljs-comment">&lt;!-- 如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用） , 其拥有对应的名称和值 , Profile就会被激活 . 如果值</span><br><span class="hljs-comment">                字段是空的 , 那么存在属性名称字段就会激活profile , 否则按区分大小写方式匹配属性值字段 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mavenVersion<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-comment">&lt;!-- 激活profile的属性的名称 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-comment">&lt;!-- 激活profile的属性的值 --&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br> <br>                <span class="hljs-comment">&lt;!-- 提供一个文件名 , 通过检测该文件的存在或不存在来激活profile . missing检查文件是否存在 , 如果不存在则激活</span><br><span class="hljs-comment">                profile . 另一方面 , exists则会检查文件是否存在 , 如果存在则激活profile .  --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">exists</span>&gt;</span>/usr/local/xbz/workspace/<span class="hljs-tag">&lt;/<span class="hljs-name">exists</span>&gt;</span><span class="hljs-comment">&lt;!-- 如果指定的文件存在 , 则激活profile .  --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>/usr/local/xbz/workspace/<span class="hljs-tag">&lt;/<span class="hljs-name">missing</span>&gt;</span><span class="hljs-comment">&lt;!-- 如果指定的文件不存在 , 则激活profile .  --&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br> <br>            <span class="hljs-comment">&lt;!-- 构建项目所需要的信息 . 参见build元素 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">defaultGoal</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">defaultGoal</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">testResources</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">testResource</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">testResource</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">testResources</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filters</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filters</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">inherited</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                                <span class="hljs-comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                                    ......<br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">inherited</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">inherited</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                            <span class="hljs-comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                                ......<br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">inherited</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><span class="hljs-comment">&lt;!-- 模块（有时称作子项目） 被构建成项目的一部分 . 列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span><br> <br>            <span class="hljs-comment">&lt;!-- 发现依赖和扩展的远程仓库列表 .  --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 参见repositories/repository元素 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">updatePolicy</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">checksumPolicy</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">updatePolicy</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">checksumPolicy</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br> <br>            <span class="hljs-comment">&lt;!-- 发现插件的远程仓库列表 , 这些插件用于构建和报表 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">updatePolicy</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">checksumPolicy</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">updatePolicy</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">checksumPolicy</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span><br> <br>            <span class="hljs-comment">&lt;!-- 该元素描述了项目相关的所有依赖 .  这些依赖组成了项目构建过程中的一个个环节 . 它们自动从项目定义的仓库中下载 . 要获取更多信息 , 请看项目依赖机制 .  --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    ......<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">reports</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">reports</span>&gt;</span><span class="hljs-comment">&lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt;</span><br> <br>            <span class="hljs-comment">&lt;!-- 该元素包括使用报表插件产生报表的规范 . 当用户执行“mvn site” , 这些报表就会运行 .  在页面导航栏能看到所有报表的链接 . 参见reporting元素 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">reporting</span>&gt;</span><br>                ......<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">reporting</span>&gt;</span><br> <br>            <span class="hljs-comment">&lt;!-- 参见dependencyManagement元素 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                        ......<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 参见distributionManagement元素 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span><br>                ......<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 参见properties元素 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 模块（有时称作子项目） 被构建成项目的一部分 . 列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 发现依赖和扩展的远程仓库列表 .  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 包含需要连接到远程仓库的信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 如何处理远程仓库里发布版本的下载 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><span class="hljs-comment">&lt;!-- true或者false表示该仓库是否为下载某种类型构件（发布版 , 快照版）开启 .   --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">updatePolicy</span>&gt;</span><span class="hljs-comment">&lt;!-- 该元素指定更新发生的频率 . Maven会比较本地POM和远程POM的时间戳 . 这里的选项是：always（一直） , daily（默认 , 每日） , interval：X（这里X是以分钟为单位的时间间隔） , 或者never（从不） .  --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">checksumPolicy</span>&gt;</span><span class="hljs-comment">&lt;!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略） , fail（失败） , 或者warn（警告） .  --&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--  如何处理远程仓库里快照版本的下载 . 有了releases和snapshots这两组配置 , POM就可以在每个单独的仓库中 , 为每种类型的构件采取不同的 策略 . 例如 , 可能有人会决定只为开发目的开启对快照版本下载的支持 . 参见repositories/repository/releases元素  --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">updatePolicy</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">checksumPolicy</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>banseon-repository-proxy<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-comment">&lt;!-- 远程仓库唯一标识符 . 可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>banseon-repository-proxy<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-comment">&lt;!-- 远程仓库名称 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://127.0.0.1:8888/repository/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-comment">&lt;!-- 远程仓库URL , 按protocol://hostname/path形式 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><span class="hljs-comment">&lt;!--  用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留） . Maven 2为其仓库提供了一个默认的布局；然 而 , Maven 1.x有一种不同的布局 . 我们可以使用该元素指定布局是default（默认）还是legacy（遗留） .  --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 发现插件的远程仓库列表 , 这些插件用于构建和报表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span><br>            ......<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 该元素描述了项目相关的所有依赖 .  这些依赖组成了项目构建过程中的一个个环节 . 它们自动从项目定义的仓库中下载 . 要获取更多信息 , 请看项目依赖机制 .  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-comment">&lt;!-- 依赖的group ID --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-artifact<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-comment">&lt;!-- 依赖的artifact ID --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!-- 依赖的版本号 .  在Maven 2里, 也可以配置成版本号的范围 .  --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><span class="hljs-comment">&lt;!--  依赖类型 , 默认类型是jar . 它通常表示依赖的文件的扩展名 , 但也有例外 . 一个类型可以被映射成另外一个扩展名或分类器 . 类型经常和使用的打包方式对应 ,  尽管这也有例外 . 一些类型的例子：jar , war , ejb-client和test-jar . 如果设置extensions为 true , 就可以在 plugin里定义新的类型 . 所以前面的类型的例子不完整 .  --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span><span class="hljs-comment">&lt;!--  依赖的分类器 . 分类器可以区分属于同一个POM , 但不同构建方式的构件 . 分类器名被附加到文件名的版本号后面 . 例如 , 如果你想要构建两个单独的构件成 JAR , 一个使用Java 1.4编译器 , 另一个使用Java 6编译器 , 你就可以使用分类器来生成两个单独的JAR构件 .  --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-comment">&lt;!-- 依赖范围 . 在项目发布过程中 , 帮助决定哪些构件被包括进来 . 欲知详情请参考依赖机制 . </span><br><span class="hljs-comment">                  - compile ：默认范围 , 用于编译</span><br><span class="hljs-comment">                  - provided：类似于编译 , 但支持你期待jdk或者容器提供 , 类似于classpath</span><br><span class="hljs-comment">                  - runtime: 在执行时需要使用</span><br><span class="hljs-comment">                  - test:    用于test任务时使用</span><br><span class="hljs-comment">                  - system: 需要外在提供相应的元素 . 通过systemPath来取得</span><br><span class="hljs-comment">                  - systemPath: 仅用于范围为system . 提供相应的路径</span><br><span class="hljs-comment">                  - optional:   当项目自身被依赖时 , 标注依赖是否传递 . 用于连续依赖时使用 --&gt;</span><br> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">systemPath</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">systemPath</span>&gt;</span><span class="hljs-comment">&lt;!-- 仅供system范围使用 . 注意 , 不鼓励使用这个元素 , 并且在新的版本中该元素可能被覆盖掉 . 该元素为依赖规定了文件系统上的路径 . 需要绝对路径而不是相对路径 . 推荐使用属性匹配绝对路径 , 例如$&#123;java.home&#125; .  --&gt;</span><br>            <span class="hljs-comment">&lt;!-- 当计算传递依赖时 ,  从依赖构件列表里 , 列出被排除的依赖构件集 . 即告诉maven你只依赖指定的项目 , 不依赖项目的依赖 . 此元素主要用于解决版本冲突问题 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-comment">&lt;!-- 可选依赖 , 如果你在项目B中把C依赖声明为可选 , 你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖 . 可选依赖阻断依赖的传递性 .  --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">reports</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">reports</span>&gt;</span><span class="hljs-comment">&lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 该元素描述使用报表插件产生报表的规范 . 当用户执行“mvn site” , 这些报表就会运行 .  在页面导航栏能看到所有报表的链接 .  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">reporting</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">excludeDefaults</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">excludeDefaults</span>&gt;</span><span class="hljs-comment">&lt;!-- true , 则 , 网站不包括默认的报表 . 这包括“项目信息”菜单中的报表 .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><span class="hljs-comment">&lt;!-- 所有产生的报表存放到哪里 . 默认值是$&#123;project.build.directory&#125;/site .  --&gt;</span><br> <br>        <span class="hljs-comment">&lt;!-- 使用的报表插件和他们的配置 .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- plugin元素包含描述报表插件需要的信息 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-comment">&lt;!-- 报表插件在仓库里的group ID --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-comment">&lt;!-- 报表插件在仓库里的artifact ID --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!-- 被使用的报表插件的版本（或版本范围） --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-comment">&lt;!-- 任何配置是否被传播到子项目 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-comment">&lt;!-- 报表插件的配置 --&gt;</span><br> <br>                <span class="hljs-comment">&lt;!-- 一组报表的多重规范 , 每个规范可能有不同的配置 . 一个规范（报表集）对应一个执行目标  . 例如 , 有1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9个报表 . 1 , 2 , 5构成A报表集 , 对应一个执行目标 . 2 , 5 , 8构成B报表集 , 对应另一个执行目标 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">reportSets</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!-- 表示报表的一个集合 , 以及产生该集合的配置 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">reportSet</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-comment">&lt;!-- 报表集合的唯一标识符 , POM继承时用到 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-comment">&lt;!-- 产生报表集合时 , 被使用的报表的配置 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">inherited</span>&gt;</span><span class="hljs-comment">&lt;!-- 配置是否被继承到子POMs --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">reports</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">reports</span>&gt;</span><span class="hljs-comment">&lt;!-- 这个集合里使用到哪些报表 --&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">reportSet</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">reportSets</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">reporting</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--  继承自该项目的所有子项目的默认依赖信息 . 这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息） , 如果group ID和artifact ID以外的一些信息没有描述 , 则通过group ID和artifact ID 匹配到这里的依赖 , 并使用这里的依赖信息 .  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                ......<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 项目分发信息 , 在执行mvn deploy后表示要发布的位置 . 有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库 .  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 部署项目产生的构件到远程仓库需要的信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">uniqueVersion</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">uniqueVersion</span>&gt;</span><span class="hljs-comment">&lt;!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>banseon-maven2<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>banseon maven2<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>file://$&#123;basedir&#125;/target/deploy<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 构件的快照部署到哪里？如果没有配置该元素 , 默认部署到repository元素配置的仓库 , 参见distributionManagement/repository元素 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">uniqueVersion</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">uniqueVersion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>banseon-maven2<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Banseon-maven2 Snapshot Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span><br> <br>        <span class="hljs-comment">&lt;!-- 部署项目的网站需要的信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">site</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>banseon-site<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-comment">&lt;!-- 部署位置的唯一标识符 , 用来匹配站点和settings.xml文件里的配置 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>business api website<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-comment">&lt;!-- 部署位置的名称 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-comment">&lt;!-- 部署位置的URL , 按protocol://hostname/path形式 --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">site</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">downloadUrl</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">downloadUrl</span>&gt;</span><span class="hljs-comment">&lt;!-- 项目下载页面的URL . 如果没有该元素 , 用户应该参考主页 . 使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制） .  --&gt;</span><br> <br>        <span class="hljs-comment">&lt;!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置） , 这里列出构件的重定位信息 .  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relocation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-comment">&lt;!-- 构件新的group ID --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-comment">&lt;!-- 构件新的artifact ID --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!-- 构件新的版本号 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span><span class="hljs-comment">&lt;!-- 显示给用户的 , 关于移动的额外信息 , 例如原因 .  --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">relocation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">status</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">status</span>&gt;</span><span class="hljs-comment">&lt;!--  给出该构件在远程仓库的状态 . 不得在本地项目中设置该元素 , 因为这是工具自动更新的 . 有效的值有：none（默认） , converted（仓库管理员从 Maven 1 POM转换过来） , partner（直接从伙伴Maven 2仓库同步过来） , deployed（从Maven 2实例部 署） , verified（被核实时正确的和最终的） .  --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 以值替代名称 , Properties可以在整个POM中使用 , 也可以作为触发条件（见settings.xml配置文件里activation元素的说明） . 格式是&lt;name&gt;value&lt;/name&gt; .  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version1</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version2</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version2</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识——类型信息</title>
    <link href="/2019/10/16/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/"/>
    <url>/2019/10/16/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="1、为什么需要RTTI"><a href="#1、为什么需要RTTI" class="headerlink" title="1、为什么需要RTTI"></a>1、为什么需要RTTI</h1><p>RTTI的含义：在运行时，识别一个对象的类型。</p><span id="more"></span><h1 id="2、Class对象"><a href="#2、Class对象" class="headerlink" title="2、Class对象"></a>2、Class对象</h1><p>Class对象包含了与类有关的信息，每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生一个Class对象。为了生成这个对象，使用了jvm中的类加载器。</p><p>所有类都是对其第一次使用时，动态加载到jvm中，当程序创建第一个对类的静态成员的引用时，就会加载这个类，这证明构造器也是类的静态方法，因此，使用new创建类的新对象也会被当做对类静态成员的引用。</p><p>类加载器先检查这个类的Class对象是否已经加载，如尚未加载，默认的类加载器就会根据类名查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良的Java代码（这是java中用于安全防范目的的措施之一）。</p><p>一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。例：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy</span></span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Candy&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gum</span></span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Gum&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cookie</span></span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cookie&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SweetShop</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;In main&quot;</span>);<br>        <span class="hljs-keyword">new</span> Candy();<br>        System.out.println(<span class="hljs-string">&quot;After create Candy&quot;</span>);<br>        <span class="hljs-keyword">try</span>&#123;<br>            Class.forName(<span class="hljs-string">&quot;Gum&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Couldn&#x27;t find Gum&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Aftet Class.forName(\&quot;Gum\&quot;)&quot;</span>);<br>        <span class="hljs-keyword">new</span> Cookie();<br>        System.out.println(<span class="hljs-string">&quot;After create Cookie&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* output:</span><br><span class="hljs-comment">In main</span><br><span class="hljs-comment">Candy</span><br><span class="hljs-comment">After create Candy</span><br><span class="hljs-comment">Gum</span><br><span class="hljs-comment">Aftet Class.forName(&quot;Gum&quot;)</span><br><span class="hljs-comment">Cookie</span><br><span class="hljs-comment">After create Cookie</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>从输出结果可以看到，Class对象仅在需要的时候才会加载，static初始化也是在类加载时进行的。</p><p>Class.forName()方法是Class类（所有Class对象都属于Class类）的一个static成员，它是取得Class对象引用的一种方法（这里忽略了返回值），它接受一个类名作为输入。这里对forName的调用是为了它的副作用：如果Gum类还没有被加载就加载它。使用forName的好处是，你不需要为了得到Class对象的引用而创建该类型的对象。但是如果你已经有一个对象，你可以通过getClass方法来获取Class引用，该方法属于Object的一部分。</p><p>Class包含很多有用的方法，下面是其中的一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HasBatteries</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Waterproof</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Shoots</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Toy</span></span>&#123;<br>    Toy()&#123;&#125;<br>    Toy(<span class="hljs-keyword">int</span> i)&#123;&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FancyToy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Toy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HasBatteries</span>,<span class="hljs-title">Waterproof</span>,<span class="hljs-title">Shoots</span></span>&#123;<br>    FancyToy()&#123; <span class="hljs-keyword">super</span>(<span class="hljs-number">1</span>); &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TyoTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">(Class c)</span></span>&#123;<br>        <span class="hljs-comment">//getName()返回全限定类名（包括包名）， isInterface()判断是否接口</span><br>        System.out.println(<span class="hljs-string">&quot;Class name: &quot;</span> + c.getName() + <span class="hljs-string">&quot; is interface? [&quot;</span> + c.isInterface() + <span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-comment">//getSimpleName()返回类名</span><br>        System.out.println(<span class="hljs-string">&quot;Simple name: &quot;</span> +c.getSimpleName());<br>        <span class="hljs-comment">//getCanonicalName()返回全限定类名（包括包名，Java SE5中引入）</span><br>        System.out.println(<span class="hljs-string">&quot;Canonical name: &quot;</span> + c.getCanonicalName());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Class c = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            c = Class.forName(<span class="hljs-string">&quot;test.FancyToy&quot;</span>); <span class="hljs-comment">//必须使用全限定名</span><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Can&#x27;t find FancyToy&quot;</span>);<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br>        printInfo(c);<br>        <span class="hljs-keyword">for</span> (Class face:c.getInterfaces())&#123; <span class="hljs-comment">//getInterfaces()返回所实现的全部接口的Class对象引用</span><br>            printInfo(face);<br>        &#125;<br>        Class up = c.getSuperclass(); <span class="hljs-comment">//getSuperclass()返回父类的Class对象引用</span><br>        Object obj = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//newInstance()虚拟构造器，创建一个该类型的对象，该类必须有默认构造器</span><br>            obj = up.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Can&#x27;t access&quot;</span>);<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Can&#x27;t instantiate&quot;</span>);<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br>        printInfo(obj.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java还提供另一种方法来生成对Class对象的引用，即使用<strong>类字面常量</strong>。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c = FancyToy.class<br></code></pre></td></tr></table></figure><p>这样做不仅更简单，而且更安全，因为它在编译时就收到检查（因此不需要置于try语句块中）。类字面常量不仅可以应用于普通类，而且可以应用于接口、数组以及基本数据类型。另外，对于基本数据类型的包装类，还有一个标准字段TYPE，TYPE字段是一个引用，指向对应的基本数据类型的Class对象，例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>.class == Integer.TYPE;<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>注意！！！当使用.class来创建Class对象的引用时，不会自动地初始化该Class对象（这和forName方法创建Class对象时不同），为了使用类而做的准备实际包含三个步骤：</p><p>（1）加载。这由类加载器执行，该步骤将查找字节码，并从这些字节码创建一个Class对象。</p><p>（2）链接。验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用。</p><p>（3）初始化。如果该类具有父类，则对其初始化，执行静态初始化器和静态初始化块。</p><p>初始化被延迟到对静态方法（包括构造器）或者非常数静态域进行首次引用时才执行。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Initable</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> staticFinal = <span class="hljs-number">47</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> staticFinal2 = ClassInitialization.ran.nextInt(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">static</span> &#123; System.out.println(<span class="hljs-string">&quot;Initializing initable&quot;</span>); &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Initable2</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> staticNonFinal = <span class="hljs-number">147</span>;<br>    <span class="hljs-keyword">static</span> &#123; System.out.println(<span class="hljs-string">&quot;Initializing initable2&quot;</span>); &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassInitialization</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Random ran = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Class initable = Initable.class;<br>        System.out.println(<span class="hljs-string">&quot;After creating Initable ref&quot;</span>);<br>        System.out.println(Initable.staticFinal);<br>        System.out.println(Initable.staticFinal2);<br>        System.out.println(<span class="hljs-string">&quot;===================&quot;</span>);<br>        System.out.println(Initable2.staticNonFinal);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* output:</span><br><span class="hljs-comment">After creating Initable ref</span><br><span class="hljs-comment">47</span><br><span class="hljs-comment">Initializing initable</span><br><span class="hljs-comment">258</span><br><span class="hljs-comment">===================</span><br><span class="hljs-comment">Initializing initable2</span><br><span class="hljs-comment">147</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果一个static final值是“编译期常量”，就像Initable.staticFinal那样，那么这个值不需要对Initable类进行初始化就可以访问。但是，仅仅将一个域设置为static和final还不足以确保这种行为，例如Initable.staticFinal2的访问就会强制进行类的初始化，因为它不是一个编译期常量。</p><p>如果一个static域不是final的，那么对它访问时，要先进行链接和初始化，就像对Initable2.staticNonFinal的访问中所看到的那样。</p><p>Class&lt;T&gt;  和Class&lt;?&gt;的区别：Class&lt;T&gt;的对象引用只能指向T类的Class对象，而Class&lt;?&gt;没有限制，和Class等价。Class&lt;?&gt;对于Class的好处是它表示你不是因为碰巧或疏忽而使用了一个不同类型的对象（Class引用表示的就是它所指向的对象的确切类型，它可以制造类的实例，一般来说给Class引用赋值后就不要改变它，或者使用Class&lt;T&gt;来进行限制，如果要把引用指向其它类(非原先类的子类)，最好用Class&lt;?&gt;）。</p><h1 id="3、类型转换前先做检查"><a href="#3、类型转换前先做检查" class="headerlink" title="3、类型转换前先做检查"></a>3、类型转换前先做检查</h1><p>RTTI形式包括：</p><p>（1）传统的类型转换，如“(Shape)”，由RTTI保证类型转换的正确性，如果执行了一个错误的类型转换，则抛出一个ClassCastException异常。</p><p>（2）代表对象类型的Class对象。通过查询Class对象可以获取运行时所需的信息。</p><p>（3）关键字instanceof，它返回一个布尔值，告诉我们对象是不是某个特定类型的实例。可以用提问的方式使用它，例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> Dog)<br>((Dog) x).bark();<br></code></pre></td></tr></table></figure><p>在将x转型为一个Dog前，先用if语句检查x是否从属于Dog类。</p><p>动态instanceof：class.isInstance(obj)方法提供了一种动态测试对象的途径，即对象obj能否转化为class所指向的类的对象。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Class c = Pet.class;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        System.out.println(c.isInstance(dog));<span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pet</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>对obj.instanceof(class)，在编译时编译器需要知道类的具体类型</p><p>对class.isInstance(obj)，编译器在运行时才进行类型检查，故可用于反射，泛型中</p><h1 id="4、反射：运行时的类信息"><a href="#4、反射：运行时的类信息" class="headerlink" title="4、反射：运行时的类信息"></a>4、反射：运行时的类信息</h1><p>Class类与java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了……  //TODO</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[转载] Java正则表达式之贪婪型、勉强型和占有型</title>
    <link href="/2019/10/15/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%8B%E8%B4%AA%E5%A9%AA%E5%9E%8B%E3%80%81%E5%8B%89%E5%BC%BA%E5%9E%8B%E5%92%8C%E5%8D%A0%E6%9C%89%E5%9E%8B/"/>
    <url>/2019/10/15/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%8B%E8%B4%AA%E5%A9%AA%E5%9E%8B%E3%80%81%E5%8B%89%E5%BC%BA%E5%9E%8B%E5%92%8C%E5%8D%A0%E6%9C%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h1><p>量词描述了一个模式吸收输入文本的方式。</p><span id="more"></span><p>有以下三种：</p><p><img src="/2019/10/15/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%8B%E8%B4%AA%E5%A9%AA%E5%9E%8B%E3%80%81%E5%8B%89%E5%BC%BA%E5%9E%8B%E5%92%8C%E5%8D%A0%E6%9C%89%E5%9E%8B/4.png"></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function"></span>&#123;<br>String str=<span class="hljs-string">&quot;&lt;aaa&lt;bbb&gt;ccc&lt;ddd&gt;eee&gt;&quot;</span>;<br>System.out.println(str.replaceAll(<span class="hljs-string">&quot;&lt;.+&gt;&quot;</span>,<span class="hljs-string">&quot;####&quot;</span>));<br>System.out.println(str.replaceAll(<span class="hljs-string">&quot;&lt;.+?&gt;&quot;</span>,<span class="hljs-string">&quot;####&quot;</span>));<br>System.out.println(str.replaceAll(<span class="hljs-string">&quot;&lt;.++&gt;&quot;</span>,<span class="hljs-string">&quot;####&quot;</span>));<br>System.out.println(str.replaceAll(<span class="hljs-string">&quot;&lt;d++&gt;&quot;</span>,<span class="hljs-string">&quot;####&quot;</span>));<br>&#125;<br>&#125;<br><span class="hljs-comment">/* output:</span><br><span class="hljs-comment">####</span><br><span class="hljs-comment">####ccc####eee&gt;</span><br><span class="hljs-comment">&lt;aaa&lt;bbb&gt;ccc&lt;ddd&gt;eee&gt;</span><br><span class="hljs-comment">&lt;aaa&lt;bbb&gt;ccc####eee&gt;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>下面说明：</p><p>贪婪型最好说明即让.+尽可能匹配更多的字符。</p><p>勉强性是从左到右让.+尽可能匹配最少的字符，这里是第一个误区，并不是匹配最短的，而是从左向右查找过程中没遇到一个可以输出的结果就输出，所以上例中被匹配掉的是&lt;aaa&lt;bbb&gt;和&lt;ddd&gt;   而不是&lt;bbb&gt; &lt;ddd&gt;。</p><p>对于占有型，它是在贪婪型的基础上不回溯，因为匹配过程是从左到右遍历，对于贪婪型和勉强型为了获得符合要求的结果都要保存很多的中间状态以便回溯。但是对于占有型，它不支持回溯，所以在第三个输出中字符串的第一个&lt;和正则表达式的&lt;匹配，而随后的所以字符串都和.+匹配，这个时候没有字符与&gt;匹配，而对于第四个输出&lt;ddd&gt;的第一个&lt;与正则表达式的&lt;匹配d++与中间的d匹配，&gt;与&gt;匹配，匹配成功。这是第二个误区，许多文章都没有把这个类型看透。</p><p>另外需要注意的是，所谓贪婪型、勉强性和占有型只是对于量词而言的并不是对于整个正则表达式。也就是说贪婪型匹配尽量多的字符，勉强性匹配尽量少的字符（从左向右），占有型匹配尽量多的字符并不支持回溯。</p><p>本文转载自<a href="https://blog.csdn.net/mushao999/article/details/46331145">https://blog.csdn.net/mushao999/article/details/46331145</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>正则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识——字符串</title>
    <link href="/2019/10/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2019/10/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="1、不可变String"><a href="#1、不可变String" class="headerlink" title="1、不可变String"></a>1、不可变String</h3><p>String对象是不可变的（final的）。String类中每一个看起来会修改String值的方法实际都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象则丝毫未动。</p><h3 id="2、重载“-”与StringBuilder"><a href="#2、重载“-”与StringBuilder" class="headerlink" title="2、重载“+”与StringBuilder"></a>2、重载“+”与StringBuilder</h3><p>String对象具有只读特性，指向它的任何引用都不可能改变它的值。</p><p>不可变性会带来一定的效率问题。String对象重载的“+”操作符就是一个例子。重载的意思是，一个操作符在应用与特定的类时，被赋予了特殊的意义（用于String的“+”与“+=”是Java中仅有的两个重载过的操作符，而java不允许程序员重载任何操作符）。</p><span id="more"></span><p>操作符“+”可以用来连接String，但编译器在工作时，实际是创建了一个StringBuilder对象（在Java SE5之前，用的是StringBuffer，它是线程安全的），并调用它的append方法把字符串连接起来，最好调用toString方法生成结果。如果使用append(str1 + “:” + str2)，这样编译器会创建另一个StringBuilder对象处理括号内的字符串操作，所以最好不要这样做。</p><h3 id="3、无意识的递归"><a href="#3、无意识的递归" class="headerlink" title="3、无意识的递归"></a>3、无意识的递归</h3><p>每个类都继承自Object，因此每个类都有toString方法。如果你希望toString方法打印出对象的内存地址，也许你会考虑this关键字，例:</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;address: &quot;</span> + <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当你创建对象，并将其打印出来的时候，会得到一串非常长的异常。其实，当上面的代码运行时，因为编译器看到一个String对象后面跟着一个“+”，而再后面的对象不是String，于是编译器试着把this转换成一个String，这就会调用this上的toString方法，于是发生了递归调用。如果真的想打印出对象的内存地址，应该调用super.toString()方法。</p><h3 id="4、String上的操作"><a href="#4、String上的操作" class="headerlink" title="4、String上的操作"></a>4、String上的操作</h3><p>详情看jdk文档。</p><h3 id="5、格式化输出"><a href="#5、格式化输出" class="headerlink" title="5、格式化输出"></a>5、格式化输出</h3><p>类似C语言的格式化输出，两种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.format(<span class="hljs-string">&quot;Row 1: [%d %f]\n&quot;</span>,x,y);<br>System.out.printf(<span class="hljs-string">&quot;Row 1: [%d %f]\n&quot;</span>,x,y);<br></code></pre></td></tr></table></figure><p>在Java中，所有新的格式化功能都由java.util.Formatter类处理。当你创建一个Formatter对象时。需要向其构造器传递一些信息，告诉它最终的结果将向哪里输出。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Formatter f = <span class="hljs-keyword">new</span> Formatter(System.out);<br>f.format(<span class="hljs-string">&quot;%s The Turtle is at (%d, %d)\n&quot;</span>, name, x, y);<br></code></pre></td></tr></table></figure><p>Formatter的构造器经过重载可以接受多种输出目的地，不过最常用的还是PrintStream()（如上例）、OutputStream和File。</p><p>格式化说明符：</p><p>插入数据时，如果想控制空格与对齐，需要更加复杂精细的格式修饰符，以下是其抽象语法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">%[flags][width][.precision]<span class="hljs-keyword">conversion</span><br></code></pre></td></tr></table></figure><p>flags控制对齐。默认是右对齐，使用“-”改变对齐方向。width控制一个域的最小长度，必要时添加空格来达到最小长度。precision指明数据的最大尺寸，但是将它应用于浮点数时，表示小数部分要显示出来位数（默认6位），如果小数位数过多则舍入，太少则在尾部补0；应用于整数时则会触发异常。例：%-15.15s表示这个域的最小长度是15个字符，字符串的最大长度是15，过长则截断，过短则加空格，对齐方式是左对齐。%15.10s表示右对齐，域的最小长度是15个字符，字符串的最大长度是10，如果字符串长度大于10，则截断，再在前面加5个空格（说明域的最小长度width可以大于数据的最大长度precision，这两个长度指的不是同一个东西）。%10.2f说明右对齐，域的最小长度是10，小数位数是2。</p><p>String.format()是一个static方法，它接受与Formatter.format()方法一样的参数，但返回一个对象。</p><h3 id="6、正则表达式"><a href="#6、正则表达式" class="headerlink" title="6、正则表达式"></a>6、正则表达式</h3><p><strong>-？</strong> 表示可能有一个负号，有或没有都能匹配，？表示可能有一个东西。</p><p>正则表达式中\d表示一位数字，而在java中要用\\d表示，因为java中的\\表示正则表达式中的反斜线，其后的字符具有特殊意义。正则表达式中\\代表一个普通的反斜线，而在java中要表示为\\\\（java中表示一个反斜线也要在它前面加一个反斜线进行转义，所以后两个反斜线表示java中的字符\）.</p><p>要表示一个或多个之前的表达式，应该使用+。因此，要表示“可能有一个负号，后面跟着一个或多个数字”，可以这样：**-？\\d+**。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerMatch</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;-1234&quot;</span>.matches(<span class="hljs-string">&quot;-?\\d+&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;5678&quot;</span>.matches(<span class="hljs-string">&quot;-?\\d+&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;+1234&quot;</span>.matches(<span class="hljs-string">&quot;-?\\d+&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;+5678&quot;</span>.matches(<span class="hljs-string">&quot;(-|\\+)?\\d+&quot;</span>));<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* output:</span><br><span class="hljs-comment">true</span><br><span class="hljs-comment">true</span><br><span class="hljs-comment">false</span><br><span class="hljs-comment">true</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>在正则表达式中，括号有着将表达式分组的效果，|表示或操作，+在正则表达式里有特殊意义，所以表示一个普通加号要进行转义。正则表达式里的空格会影响匹配，所以不要为了表达式好看而加空格。</p><p>String类的split()方法的功能是“将字符串从正则表达式匹配的地方切开”。replaceAll()方法能把字符串中所有与正则表达式匹配的地方替换成其他字符串，replaceFirst()方法只能在第一次出现的地方替换。</p><p><img src="/2019/10/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/1.png"></p><p><img src="/2019/10/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/2.png"></p><p><img src="/2019/10/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/3.png"></p><p>量词，请看另一篇文章   <a href="/2019/10/15/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%8B%E8%B4%AA%E5%A9%AA%E5%9E%8B%E3%80%81%E5%8B%89%E5%BC%BA%E5%9E%8B%E5%92%8C%E5%8D%A0%E6%9C%89%E5%9E%8B/">Java正则表达式之贪婪型、勉强型和占有型</a></p><h3 id="7、扫描输入"><a href="#7、扫描输入" class="headerlink" title="7、扫描输入"></a>7、扫描输入</h3><p>Scanner的构造器可以接受任何类型的输入对象，包括File对象、InputStream、String或者Readable对象。Readable是Java SE5中新加入的接口，表示“具有read()方法的某种东西”，例如BufferReader就属于这一类。</p><p>有了Scanner，所有的输入、分词以及翻译的操作都隐藏在不同类型的next方法中。普通的next方法返回下一个String。所有基本类型（除char之外）都有对应的next方法，包括BigDecimal和BigInteger。所有的next方法只有在找到一个完整的分词之后才会返回。Scanner还有相应的hasNext方法，用以判断下一个输入分词是否所需类型。</p><p>Scanner有一个假设，在输入结束时抛出IOException，所以Scanner会把IOException吞掉。默认情况下，Scanner根据空白字符对输入进行分词，但是你可以通过正则表达式指定自己的界定符。</p><p>除了可以扫描基本类型外，你可以使用自定义的正则表达式进行扫描，这在扫描复杂数据时非常有用。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>正则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识——通过异常处理错误</title>
    <link href="/2019/10/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/"/>
    <url>/2019/10/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基本异常"><a href="#1、基本异常" class="headerlink" title="1、基本异常"></a>1、基本异常</h3><p>抛出异常后，有几件事情会发生。首先，同Java中其他对象的创建一样，将使用new在堆上创建异常对象。然后，当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序，这个恰当的地方就是异常处理程序。</p><p>所有标准异常类都有两个构造器，一个是默认构造器，另一个是接受字符串作为参数的构造器。</p><span id="more"></span><h3 id="2、捕获异常"><a href="#2、捕获异常" class="headerlink" title="2、捕获异常"></a>2、捕获异常</h3><p>如果在方法内部抛出了异常（或者在方法内部调用的其他方法抛出了异常），这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，可以在方法内设置一个特殊的块（即try{…}）来捕获异常。</p><p>当然，抛出的异常必须在某处得到处理，即异常处理程序，针对每个要捕获的异常，得准备相应的处理程序。异常处理程序紧跟在try块之后，以关键字catch表示。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">//code that might generate exception</span><br>&#125;<span class="hljs-keyword">catch</span>(Type1 id1)&#123;<br><span class="hljs-comment">//Handle exception of Type1</span><br>&#125;<span class="hljs-keyword">catch</span>(Type2 id2)&#123;<br><span class="hljs-comment">//Handle exception of Type2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每个catch子句看起来就像是接收一个且仅接收一个特殊类型的参数的方法。可以在处理程序的内部使用标识符（id1，id2等），这与方法参数的使用很相似。有时可能用不到标识符，因为异常的类型已经给了你足够的信息来对异常进行处理但标识符并不可省略。</p><h3 id="3、创建自定义异常"><a href="#3、创建自定义异常" class="headerlink" title="3、创建自定义异常"></a>3、创建自定义异常</h3><p>要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承（不过这样的异常类并不容易找）。建立新的异常类型最简单的方法就是让编译器为你产生默认构造器。</p><h3 id="4、异常说明"><a href="#4、异常说明" class="headerlink" title="4、异常说明"></a>4、异常说明</h3><p>Java鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员。这就是异常说明，它属于方法的一部分，紧跟在形参之后，例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TooBig, TooSmall, DivZero</span>&#123; <span class="hljs-comment">//... &#125;</span><br></code></pre></td></tr></table></figure><p>如果在方法的代码里产生（new）了异常却没有处理，编译器会发现这个问题并提醒你：要么处理这个异常，要么在异常说明中表明此方法将产生异常。</p><h3 id="5、捕获所有异常"><a href="#5、捕获所有异常" class="headerlink" title="5、捕获所有异常"></a>5、捕获所有异常</h3><p>可以只写一个异常处理程序来捕获所有类型的异常，通过捕获异常类型的父类Exception，就可以做到这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">catch</span>(Exception e)&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这将捕获所有异常，所以最好把它放在处理程序列表的末尾，以防它抢在其他处理程序之前先把异常捕获了。</p><h3 id="6、Java标准异常"><a href="#6、Java标准异常" class="headerlink" title="6、Java标准异常"></a>6、Java标准异常</h3><p>Throwable这个 Java类被用来表示任何可以作为异常被抛出的类。Throwable对象可分为两种类型（即继承Throwable的类型）：Error用来表示编译时和系统错误（除特殊情况外，一般不需要你关心）；Exception是可以被抛出的基本类型。</p><p>特例：RuntimeException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(t == <span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br></code></pre></td></tr></table></figure><p>在上面这个例子中，如果必须对传递给方法的每个引用都检查其是否为null，这听起来着实吓人。幸运的是，你不必亲自来做，它属于Java的标准运行时检测的一部分。如果对null引用进行调用，Java会自动抛出NullPointerException异常，所以上述代码是多余的。</p><p>属于运行时异常类型很多，这些异常都是从RuntimeException类继承而来。并且，也不需要在异常说明中声明方法将抛出RuntimeException类型的异常（或者它的子类异常），它们被称为不受检查异常。这种异常属于错误，将被自动捕获。</p><h3 id="7、使用finally进行清理"><a href="#7、使用finally进行清理" class="headerlink" title="7、使用finally进行清理"></a>7、使用finally进行清理</h3><p>对于一些代码，可能希望无论try块中的异常是否抛出，它们都能得到执行。为了达到这个效果，可以在异常处理程序后面加上finally子句。完整的异常处理程序看起来像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">//might throw some exception</span><br>&#125;<span class="hljs-keyword">catch</span>(A a)&#123;<br><span class="hljs-comment">//handler for A</span><br>&#125;<span class="hljs-keyword">catch</span>(B b)&#123;<br><span class="hljs-comment">//handler for B</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-comment">//activities that happen every time</span><br>&#125;<br></code></pre></td></tr></table></figure><p>finally子句总能被执行，即使try块里有return语句。</p><h3 id="8、异常匹配"><a href="#8、异常匹配" class="headerlink" title="8、异常匹配"></a>8、异常匹配</h3><p>抛出异常的时候，异常处理系统会按照代码的书写顺序找出最近的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。</p><p>查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。子类的对象也可以匹配其父类的处理程序。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识——持有对象</title>
    <link href="/2019/10/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/"/>
    <url>/2019/10/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p> 保存对象可以使用数组，但限制是数组的尺寸是固定的。另一种方法是使用容器类。例如，Set对于每一个值都只保存一个对象，Map允许保存键值对（key-value）。Java容器类都可以自动调整自己的尺寸。</p><span id="more"></span><h3 id="1、泛型和类型安全的容器"><a href="#1、泛型和类型安全的容器" class="headerlink" title="1、泛型和类型安全的容器"></a>1、泛型和类型安全的容器</h3><p>例如，如果想要定义一个用来保存Apple对象的ArrayList，你可以声明ArrayList&lt;Apple&gt;，其中尖括号括起来的是类型参数，它指定了这个容器实例可以保存的类型。通过使用泛型，就可以在编译期防止将错误类型的对象放置到这个容器中。向上转型也可以像作用于其他类型一样作用于泛型。例：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gala</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Apple</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fuji</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Apple</span></span>&#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericsAndUpcasting</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        apples.add(<span class="hljs-keyword">new</span> Apple());<br>        apples.add(<span class="hljs-keyword">new</span> Gala());<br>        apples.add(<span class="hljs-keyword">new</span> Fuji());<br>        <span class="hljs-keyword">for</span> (Apple a:apples)&#123;<br>            System.out.println(a);<br>        &#125;<br>        <span class="hljs-comment">/*另一种遍历方法</span><br><span class="hljs-comment">        for (int i = 0; i &lt; apples.size(); i++)&#123;</span><br><span class="hljs-comment">            apples.get(i);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h3><p>Java容器类的用途是“保存对象”，并将其划分为两个不同的概念：</p><p>（1）Collection。一个独立元素的队列，这些元素都服从一条或多条规则。List必须按照插入的顺序保存元素，而Set不能有重复元素。Queue按照排队规则来确定对象的产生顺序（通常与它们被插入的顺序相同，Queue只允许从一端插入对象，从另一端移除对象）。</p><p>（2）Map。一组成对的“键值对”对象，允许你使用键来查找值。ArrayList允许你使用数字来查找值，在某种意义上讲，它将数字与对象关联在了一起。映射表允许我们使用另一个对象来查找某个对象，它也被称为“关联数组”或“字典”。</p><p>在理想情况下，你编写的大部分代码都是在和这些接口打交道，并且你唯一需要指定所使用的精确类型的地方就是在创建的时候。因此，你可以像下面这样创建一个List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;();<br></code></pre></td></tr></table></figure><p>注意，ArrayList已经被向上转型为List，使用接口的目的在于如果你决定去修改你的实现（List的实现），你所需的只是在创建处修改它，像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> LinkedList&lt;Apple&gt;();<br></code></pre></td></tr></table></figure><p>因此，你应该创建一个具体类的对象，将其转型为对应的接口，然后在其余的代码中都使用这个接口。</p><h3 id="3、添加一组元素"><a href="#3、添加一组元素" class="headerlink" title="3、添加一组元素"></a>3、添加一组元素</h3><p>在java.util包中的Arrays和Collections类中有很多实用的方法，可以在一个Collection中添加一组元素，Arrays.asList()方法接受一个数组或是一个用逗号分割的元素列表（使用可变参数），并将其转换为一个List对象。 Collection.addAll()方法接受一个Collection对象，以及一个数组或一个用逗号分割的列表，将元素添加到Collection中。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddingGroups</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Collection&lt;Integer&gt; collection = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>        Integer[] moreInts = &#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>        collection.addAll(Arrays.asList(moreInts));<br>        Collections.addAll(collection,moreInts);<br>        Collections.addAll(collection,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>);<br>        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>);<br>        list.set(<span class="hljs-number">1</span>,<span class="hljs-number">99</span>); <span class="hljs-comment">//Ok--modify an element</span><br>        <span class="hljs-comment">//list.add(21);  //error</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以使用Arrays.asList()的输出，将其当做List，但在这种情况下，其底层表示的是数组，因此不能调整尺寸。</p><h3 id="4、容器的打印"><a href="#4、容器的打印" class="headerlink" title="4、容器的打印"></a>4、容器的打印</h3><p>数组的打印可以使用Arrays.toString()方法，但打印容器无需任何帮助。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintingContainers</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Collection <span class="hljs-title">fill</span><span class="hljs-params">(Collection&lt;String&gt; collection)</span></span>&#123;<br>        collection.add(<span class="hljs-string">&quot;rat&quot;</span>);<br>        collection.add(<span class="hljs-string">&quot;cat&quot;</span>);<br>        collection.add(<span class="hljs-string">&quot;dog&quot;</span>);<br>        collection.add(<span class="hljs-string">&quot;dog&quot;</span>);<br>        <span class="hljs-keyword">return</span> collection;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Map <span class="hljs-title">fill</span><span class="hljs-params">(Map&lt;String,String&gt; map)</span></span>&#123;<br>        map.put(<span class="hljs-string">&quot;rat&quot;</span>, <span class="hljs-string">&quot;Fuzzy&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;Rags&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;Bosco&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;Spot&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String[] s = &#123;<span class="hljs-string">&quot;rat&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>&#125;;<br>        System.out.println(Arrays.toString(s));<br>        System.out.println(fill(<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;()));<br>        System.out.println(fill(<span class="hljs-keyword">new</span> LinkedList&lt;String&gt;()));<br>        System.out.println(fill(<span class="hljs-keyword">new</span> HashSet&lt;String&gt;()));<br>        System.out.println(fill(<span class="hljs-keyword">new</span> TreeSet&lt;String&gt;()));<br>        System.out.println(fill(<span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;()));<br>        System.out.println(fill(<span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;()));<br>        System.out.println(fill(<span class="hljs-keyword">new</span> TreeMap&lt;String,String&gt;()));<br>        System.out.println(fill(<span class="hljs-keyword">new</span> LinkedHashMap&lt;String,String&gt;()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ArrayList和LinkedList都是List类型，两者不同之处在于执行某些操作时的性能。HashSet、TreeSet、LinkedHashSet都是set类型，HashSet是最快获取元素的方式，存储的顺序没有意义；TreeSet按照比较结果升序保存对象；LinkedHashSet按照添加的顺序保存对象。List和Set都是Collection类型。</p><p>Map.put(key,value) 方法将新增一个值，并将它与某个键（你用来查找这个值的对象）关联起来。Map.get(key)方法返回与这个键相关联的值。Map对每个键只保存一次。Map的三种基本风格：HashMap、TreeMap和LinkedHashMap。与HashSet一样，HashMap提供最快的查找技术，无顺序。TreeMap按照比较结果的升序保存键，LinkedHashMap按照插入的顺序保存键，同时保留HashMap的查询速度。</p><h3 id="5、List"><a href="#5、List" class="headerlink" title="5、List"></a>5、List</h3><p>有两种类型的List：</p><p>ArrayList，擅长随机访问，但在list中间插入和移除元素较慢。因为ArrayList的底层是用数组实现的，数组保存在连续的内存空间，插入和删除中间元素时要一个个移动后面的元素，所以比较慢。</p><p>LinkedList，通过较低代价在List中间进行插入和删除操作，提供了优化的顺序访问，但在随机访问方面较慢。因为LinkedList底层是链表实现的，链表保存在不连续的内存空间，通过指针链接，插入和删除时只需要修改前后元素指针的值就可以，所以比较快。</p><h3 id="6、迭代器"><a href="#6、迭代器" class="headerlink" title="6、迭代器"></a>6、迭代器</h3><p>迭代器（也是一种设计模式）是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道序列底层的结构。此外，迭代器通常被称为轻量级对象：创建它的代价小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span> </span>&#123; <span class="hljs-comment">//实现Iterable接口，说明这个类是可迭代的</span><br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IteratorTest</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IteratorTest</span><span class="hljs-params">(Integer[] list)</span></span>&#123;    <span class="hljs-comment">//允许通过一个数组初始化列表</span><br>        <span class="hljs-keyword">this</span>.list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(list));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> e)</span></span>&#123;<br>        list.add(e);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//Iterable接口的方法，返回一个迭代器</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator() &#123; <span class="hljs-comment">//匿名内部类实现Iterator接口，返回一个自定义的迭代器</span><br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-comment">//列表索引</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> i &lt; list.size();<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> list.get(i++);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IteratorTest it = <span class="hljs-keyword">new</span> IteratorTest(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>        Iterator iter = it.iterator();<br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123; <span class="hljs-comment">//也可以用foreach语法遍历实现了Iterable接口的类</span><br>            System.out.println(iter.next());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代器使用next()获得序列中的下一个元素，使用hasNext()检查序列中是否还有元素。如果只是向前遍历序列，并不打算修改序列对象本身，那么使用foreach语法更加简洁。</p><p>ListIterator是一个更加强大的Iterator的子类型，它只能用于各种List类的访问。Iterator只能单向移动，ListIterator可以双向移动。</p><h3 id="7、LinkedList"><a href="#7、LinkedList" class="headerlink" title="7、LinkedList"></a>7、LinkedList</h3><p>LinkedList添加了可以使其用作栈、队列或双端队列的方法。 具体可以查看jdk文档。</p><h3 id="8、Stack"><a href="#8、Stack" class="headerlink" title="8、Stack"></a>8、Stack</h3><p>栈通常是指后进先出的容器，因为最后压入的元素，第一个弹出栈。LinkedList具有能够直接实现栈的所有功能的方法，因此可以直接将LinkedList作为栈使用。不过，有时候一个真正的“栈”更能把事情讲清楚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;T&gt; storage = <span class="hljs-keyword">new</span> LinkedList&lt;T&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T v)</span></span>&#123;storage.addFirst(v);&#125;<span class="hljs-comment">//压入一个对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> storage.getFirst();&#125;<span class="hljs-comment">//返回栈顶元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> storage.removeFirst();&#125;<span class="hljs-comment">//移除并返回栈顶元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> storage.isEmpty();&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> storage.toString();&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9、Set"><a href="#9、Set" class="headerlink" title="9、Set"></a>9、Set</h3><p>Set不保存重复的元素，因此所有元素在set里面只出现一次。Set具有与Collection完全一样的接口，实际上Set就是Collection，只是行为不同。TreeSet将元素存储在红黑树数据结构中，而HashSet使用的是散列函数。LinkedHashSet因为查询速度原因也使用了散列，但是它使用了链表来维护元素的插入顺序。</p><h3 id="10、Map"><a href="#10、Map" class="headerlink" title="10、Map"></a>10、Map</h3><p>Map具有将对象映射到其他对象的能力。Map与数组和其他的Collection一样，可以很容易地扩展到多维，因此，我们可以将容器组合起来从而快速的生成强大的数据结构，例Map&lt;Person,List&lt;Pet&gt;&gt;</p><h3 id="11、Queue"><a href="#11、Queue" class="headerlink" title="11、Queue"></a>11、Queue</h3><p>队列是一个先进先出的容器，即从一端放入事物，从另一端取出，LinkedList提供了方法以支持队列的行为，并且它实现了Queue接口，因此LinkedList可以用做Queue的一种实现。</p><p>优先级队列声明下一个弹出的元素是最需要的元素（具有最高优先级）。当你在PriorityQueue上调用offer()方法来插入一个对象时，这个对象会在队列中被排序，默认的排序将使用对象在队列中的自然顺序，但你可以通过提供自己的Comparator来修改这个顺序。PriorityQueue可以确保当你调用peek()、poll()和remove()方法时，获取的元素是队列中优先级最高的元素。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2019/10/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识——内部类</title>
    <link href="/2019/10/09/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2019/10/09/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p> 可以将一个类的定义放在另一个类的内部，这就是内部类。内部类拥有其外部类的所有元素的访问权。</p><span id="more"></span><p>如果要在内部类生成对外部类的引用，可以使用外部类的名字后面紧跟 <strong>.this</strong> ，例：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Outer <span class="hljs-title">getOuter</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> Outer.<span class="hljs-keyword">this</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outerF</span><span class="hljs-params">()</span></span>&#123; Outer.<span class="hljs-keyword">this</span>.f(); &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要想在外部类的静态方法内或者其他类的任意地方直接创建内部类的对象，需要先创建外部类的对象，然后使用 <strong>.new</strong> 创建内部类对象。如果是静态内部类，那么就不需要对外部类对象的引用。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;&#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInner</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Outer o = <span class="hljs-keyword">new</span> Outer();<br><span class="hljs-comment">//        Inner n = new Inner();   //error</span><br>        Inner i = o.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;<br>        StaticInner s = <span class="hljs-keyword">new</span> StaticInner();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Other</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        Outer o = <span class="hljs-keyword">new</span> Outer();<br>        Outer.Inner i = o.n<span class="hljs-function">ew <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;<br>        Outer.StaticInner s = <span class="hljs-keyword">new</span> Outer.StaticInner();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h1><p>定义在方法内部的类，在方法内部不能访问。也可以在作用域（如if作用域）内定义一个类，这个类仅在该作用域内可以访问。</p><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>就是没有名字的类，它必须继承其他类或者实现一个接口。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Content</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Anonymous</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Content <span class="hljs-title">getContent</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Content() &#123;  <span class="hljs-comment">//插入一个类的定义</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;anonymous class&quot;</span>);<br>            &#125;<br>        &#125;;  <span class="hljs-comment">//return语句结束，要有分号</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Anonymous a = <span class="hljs-keyword">new</span> Anonymous();<br>        Content c = a.getContent();<br>        c.f();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在getContent方法的return语句中，插入了一个匿名类的定义，该类实现了Content接口（虽然没有implements关键字），然后通过new关键字创建了一个匿名类的对象，把它的引用向上转型为Content的引用作为返回值。</p><p>在上面这个匿名内部类中，使用了默认的构造器来生成Content，如果你的父类需要一个有参数的构造器，可以看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapping</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String ss;<br>    Wrapping(String s)&#123; ss = s; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> ss;&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcel</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Wrapping <span class="hljs-title">getWrapping</span><span class="hljs-params">(String s)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Wrapping(s)&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.f() + <span class="hljs-string">&quot; world!&quot;</span>;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Parcel p = <span class="hljs-keyword">new</span> Parcel();<br>        Wrapping w = p.getWrapping(<span class="hljs-string">&quot;hello&quot;</span>);<br>        System.out.println(w.f()); <span class="hljs-comment">//调用的是匿名内部类的f()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中匿名内部类继承了一个普通类Wrapping。</p><p>在匿名类中定义字段时，还可以对其执行初始化操作。如果在匿名类中使用一个在其外部定义的对象，那么编译器要求这个参数引用是final的。</p><p>匿名类中不可能有命名构造器（因为它根本没有名字！），但通过实例初始化，就能达到为匿名内部类创建一个构造器的效果。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Base</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Base constructor. i = &quot;</span> + i);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnonymousConstructor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Base <span class="hljs-title">getBase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Base(i) &#123;<br>            &#123; System.out.println(<span class="hljs-string">&quot;inside instance initializer&quot;</span>); &#125;  <span class="hljs-comment">//实例初始化</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;in anonymous f()&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Base base = getBase(<span class="hljs-number">11</span>);<br>        base.f();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此例中，不要求变量i一定是final的，因为i被传递给匿名类的父类构造器，它并不会在匿名类内部直接使用。</p><p>对于匿名内部类而言，实例初始化的实际效果就是构造器，当然它受到了限制——你不能重载实例初始化方法，所以你仅有一个这样的构造器。</p><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><p>也叫嵌套类。普通内部类的对象隐式地保存了一个引用，指向创建它的外部类对象。然而静态内部类就不是这样了。静态内部类意味着：</p><p>（1）要创建静态内部类的对象，并不需要其外部类的对象。</p><p>（2）不能从静态内部类的对象中访问非静态的外围类对象。</p><p>静态内部类与普通内部类还有一个区别，普通内部类不能有static数据和static字段，也不能包含静态内部类。但是静态内部类可以包含所有这些东西。</p><p>在普通内部类中，通过一个this引用可以链接到其外部类对象。静态内部类就没有这个特殊的this引用，这使得它类似于一个static方法。</p><h1 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h1><p>正常情况下，不能在接口内部放置任何代码，但静态内部类可以作为接口的一部分。你放到接口中的任何类都自动的是public和static的。因为类是static的，只是将静态内部类置于接口的命名空间内，这并不违反接口的规则，你甚至可以在内部类中实现其外部接口。就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ClassInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">howdy</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClassInterface</span></span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">howdy</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;howdy!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>            <span class="hljs-keyword">new</span> Test().howdy();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口的静态内部类就会显得很方便。</p><p>一个内部类被嵌套多少层并不重要，它能透明的访问它所嵌入的外部类的所有成员（即使是private的）。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MNA</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123; System.out.println(<span class="hljs-string">&quot;first level&quot;</span>);&#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">&quot;second level&quot;</span>);&#125;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>&#123;<br>                f();<br>                g();<br>                System.out.println(<span class="hljs-string">&quot;third level&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiNestingAccess</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MNA mna = <span class="hljs-keyword">new</span> MNA();<br>        MNA.A a = mna.n<span class="hljs-function">ew <span class="hljs-title">A</span><span class="hljs-params">()</span></span>;<br>        MNA.A.B b = a.n<span class="hljs-function">ew <span class="hljs-title">B</span><span class="hljs-params">()</span></span>;<br>        b.h();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要使用内部类。内部类使得多重继承的解决方案变得完整，接口解决了部分问题，而内部类有效的实现了“多重继承”。当你拥有的是抽象类或具体类而不是接口时，你只能通过内部类实现多重继承。</p><p>内部类还可以获得其他一些特性：</p><p>（1）内部类可以有多个实例，每个实例都有自己的状态信息，并且与外围类对象的信息相互独立。</p><p>（2）在单个的外围类中，可以让多个内部类以不用的方式实现同一接口，或继承同一个类。</p><p>（3）创建内部类对象（这里大概是指静态内部类）的时刻并不依赖外围类对象的创建。</p><p>（4）内部类并没有令人迷惑的“is-a”关系；它就是一个独立的实体。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Selector</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">end</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Object <span class="hljs-title">current</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sequence</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Object[] objects;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> next = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Sequence</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>        objects = <span class="hljs-keyword">new</span> Object[size];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(next &lt; objects.length)<br>            objects[next++] = x;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Selector</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>  i = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">end</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> i == objects.length;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">current</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> objects[i];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(i &lt; objects.length)<br>                i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseSeletor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Selector</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = objects.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> i == -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">current</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> objects[i];<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (i &gt; -<span class="hljs-number">1</span>)&#123;<br>                i--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Selector <span class="hljs-title">getSelector</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SSelector();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Selector <span class="hljs-title">getReverseSeletor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReverseSeletor();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>        Sequence sequence = <span class="hljs-keyword">new</span> Sequence(size);<br>        Random r = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            sequence.add(Integer.toString(r.nextInt(<span class="hljs-number">47</span>)));<br><br>        Selector selector = sequence.getSelector();<br>        <span class="hljs-keyword">while</span>(!selector.end())&#123;<br>            System.out.println(selector.current());<br>            selector.next();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;================&quot;</span>);<br><br>        Selector reSelector = sequence.getReverseSeletor();<br>        <span class="hljs-keyword">while</span>(!reSelector.end())&#123;<br>            System.out.println(reSelector.current());<br>            reSelector.next();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果Sequence不使用内部类，就必须声明“Sequence是一个Selector”，对于某个特定的Sequence只能有一个Selector。然而使用内部类很容易就能拥有另一个方法getReverseSelector()，用它来生成一个反方向遍历序列的Selector。只有内部类才有这种灵活性。</p><h1 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a><strong>闭包与回调</strong></h1><p>闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包。因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围对象的引用，在此作用域内，内部类有权操作所有的成员，包括“private”成员。</p><p>Java最具有争议的问题之一就是，人们认为Java应该包含某种类似指针的机制，以允许回调（callback）。通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。通过内部类提供闭包可以方便的实现回调功能，它比指针更灵活、更安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Teachable</span></span><br><span class="hljs-class"></span>&#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>; &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Programmer</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Programmer</span><span class="hljs-params">(String name)</span> </span>&#123; <span class="hljs-keyword">this</span>.name = name; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; System.out.println(name + <span class="hljs-string">&quot;在灯下认真敲键盘...&quot;</span>); &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">假如有一个人既是一个程序员又是一个教师，于是就需要一个特殊的类，</span><br><span class="hljs-comment">既需要实现Teachable接口，也需要继承Programmer父类。表面上看</span><br><span class="hljs-comment">起来没什么问题，问题是Teachable接口和Programmer父类里包含了</span><br><span class="hljs-comment">相同的work方法。这个时候，我们就可以通过一个仿闭包的内部类来实现这个功能。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeachableProgrammer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Programmer</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TeachableProgrammer</span><span class="hljs-params">(String name)</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">super</span>(name); &#125;<br>    <span class="hljs-comment">//教学工作依然由TeachableProgrammer类定义</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">teach</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; System.out.println(getName() + <span class="hljs-string">&quot;教师在讲台上讲解...&quot;</span>); &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Closure</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Teachable</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        非静态内部类回调外部类实现work方法，非静态内部类引用的作用仅仅是</span><br><span class="hljs-comment">        向客户类提供一个回调外部类的途径</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            teach();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//返回一个非静态内部类引用，允许外部类通过该非静态内部类引用来回调外部类的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Teachable <span class="hljs-title">getCallbackReference</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Closure();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//下面程序示范了如何让让TeachableProgrammer对象既执行“教学”的work方法，也执行“编程”的work方法。</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeachableProgrammerTest</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        TeachableProgrammer tp = <span class="hljs-keyword">new</span> TeachableProgrammer(<span class="hljs-string">&quot;李刚&quot;</span>);<br>        <span class="hljs-comment">//直接调用TeachableProgrammer类从Programmer类继承到的work方法</span><br>        tp.work();<br>        <span class="hljs-comment">//表面上调用的是Closure的work方法，</span><br>        <span class="hljs-comment">//实际上是回调TeachableProgrammer的teach方法</span><br>        tp.getCallbackReference().work();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a><strong>内部类的继承</strong></h1><p>因为内部类的构造器必须连接到指向其外部类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithInner</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritInner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WithInner</span>.<span class="hljs-title">Inner</span> </span>&#123;<br>    InheritInner(WithInner wi)&#123;<br>        wi.<span class="hljs-keyword">super</span>();  <span class="hljs-comment">//必须调用外围类的构造器</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        WithInner wi = <span class="hljs-keyword">new</span> WithInner();<br>        InheritInner ii = <span class="hljs-keyword">new</span> InheritInner(wi);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，InheritInner只继承自内部类，而不是外围类，但是在写构造器时，必须提供一个指向外围类对象的引用。</p><p>如果创建一个内部类，然后继承其外围类并重新定义此内部类时，会发生什么呢？也就是说，内部类可以被覆盖吗？答案是不能，因为这两个内部类是完全独立的两个实体，各自在自己的命名空间内。</p><p>前面提到过，可以在代码块里创建内部类，典型的方式是在一个方法体里面创建。局部内部类不能有访问说明符（就是public，private这些），因为它不是外围类的一部分，但是它可以访问当前代码块内的常量，以及此外围类的所有成员。下面的例子对局部内部类与匿名内部类的创建进行了比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Counter</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalInnerClass</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">Counter <span class="hljs-title">getCounter</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name)</span></span>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalCounter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Counter</span></span>&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LocalCounter</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//局部内部类可以有构造器</span><br>                System.out.println(<span class="hljs-string">&quot;LocalCounter()&quot;</span>);<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>&#123;<br>                System.out.print(name); <span class="hljs-comment">//访问局部常量</span><br>                <span class="hljs-keyword">return</span> count++;  <span class="hljs-comment">//访问外围类的成员</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LocalCounter();<br>    &#125;<br>    <span class="hljs-function">Counter <span class="hljs-title">getCounter2</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter() &#123;<br>            &#123;   <span class="hljs-comment">//匿名内部类不能有带名字的构造器，只能有一个实例初始化代码块</span><br>                System.out.println(<span class="hljs-string">&quot;Counter()&quot;</span>);<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.print(name);<br>                <span class="hljs-keyword">return</span> count++;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LocalInnerClass lic = <span class="hljs-keyword">new</span> LocalInnerClass();<br>        Counter<br>                c1 = lic.getCounter(<span class="hljs-string">&quot;local inner class&quot;</span>),<br>                c2 = lic.getCounter2(<span class="hljs-string">&quot;anonymous inner class&quot;</span>);<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot; &quot;</span> + c1.next());<br>        &#125;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot; &quot;</span> + c2.next());<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* output:</span><br><span class="hljs-comment">LocalCounter()</span><br><span class="hljs-comment">Counter()</span><br><span class="hljs-comment">local inner class 0</span><br><span class="hljs-comment">local inner class 1</span><br><span class="hljs-comment">local inner class 2</span><br><span class="hljs-comment">local inner class 3</span><br><span class="hljs-comment">local inner class 4</span><br><span class="hljs-comment">anonymous inner class 5</span><br><span class="hljs-comment">anonymous inner class 6</span><br><span class="hljs-comment">anonymous inner class 7</span><br><span class="hljs-comment">anonymous inner class 8</span><br><span class="hljs-comment">anonymous inner class 9</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>可以看到两个内部类对象的计数是连续的，因为它们是同一个外围类对象创建的，访问的是同一个count变量。既然局部内部类的名字在方法外不可见，那么我们为什么仍然要使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识——接口</title>
    <link href="/2019/10/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/"/>
    <url>/2019/10/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1、抽象类和抽象方法"><a href="#1、抽象类和抽象方法" class="headerlink" title="1、抽象类和抽象方法"></a>1、抽象类和抽象方法</h1><p>只有声明而没有方法体的方法为抽象方法，包含一个或多个抽象方法的类为抽象类（可以有具体实现的方法），抽象类和抽象方法都要用abstract关键字声明。抽象类不能实例化，但可以创建引用。抽象类的子类必须为父类中的所有抽象方法提供定义，否则子类也是抽象类。</p><span id="more"></span><h1 id="2、接口"><a href="#2、接口" class="headerlink" title="2、接口"></a>2、接口</h1><p>接口中的方法都是抽象方法，创建一个接口要用interface关键字代替class，并且里面的方法不需要abstract关键字。接口可以包含域，但这些域隐式地是static和final的。要让一个类遵循某个特定接口（或者是一组接口），需要使用implements关键字，它表示“interface只是它的外貌，现在我要声明它是如何工作的”。</p><p>一旦实现某个接口，其实现就是一个普通类（特殊情况，抽象类也可以实现接口）。</p><p>接口中的方法可以显式地声明为public，即使不这么做，它们也是public的。当实现一个接口时，所有实现方法必须显式的声明为public，否则编译不通过。</p><h1 id="3、完全解耦"><a href="#3、完全解耦" class="headerlink" title="3、完全解耦"></a>3、完全解耦</h1><p>只要一个方法操作的是类而非接口，那么你只能使用这个类及其子类。如果你想要将这个方法应用于不在此继承结构中的某个类，那么你就会触霉头了。接口在很大程度上放宽这种限制，因此，它使得我们可以编写可复用性更好的代码。</p><h1 id="4、Java中的多重继承"><a href="#4、Java中的多重继承" class="headerlink" title="4、Java中的多重继承"></a>4、Java中的多重继承</h1><p>C++中有多重继承这一功能，即一个类可以同时继承自多个类。Java中不能这样做，但是它可以通过实现多个接口来达到相同的目的。</p><h1 id="5、通过继承来扩展接口"><a href="#5、通过继承来扩展接口" class="headerlink" title="5、通过继承来扩展接口"></a>5、通过继承来扩展接口</h1><p>一个接口可以继承自一个或者多个接口。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识——多态</title>
    <link href="/2019/10/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81/"/>
    <url>/2019/10/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p> 多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开来。多态不仅能改善代码的组织结构和可读性，还能够创建可扩展的程序——即无论在项目最初创建时还是在需要添加新功能时都可以“生长”的程序。</p><span id="more"></span><h3 id="1、再论向上转型"><a href="#1、再论向上转型" class="headerlink" title="1、再论向上转型"></a>1、再论向上转型</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instrument</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Instrument.play()&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Wind.play()&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Music</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tune</span><span class="hljs-params">(Instrument i)</span></span>&#123;<br>        i.paly();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Wind flute = <span class="hljs-keyword">new</span> Wind();  <span class="hljs-comment">//甚至可以这样写：Instrument flute = new Wind();</span><br>        tune(flute);   <span class="hljs-comment">//upcasting</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/*output:</span><br><span class="hljs-comment">Wind.play()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果让tune()方法直接接受一个wind引用作为自己的参数，似乎会更为直观。但是这样做就需要为Instrument的每个子类都编写一个新的tune()方法，这就需要更多的编程。把wind类型看做Instrument类型会使编程更简单，这正是多态所允许的。</p><h3 id="2、转机"><a href="#2、转机" class="headerlink" title="2、转机"></a>2、转机</h3><p>将一个方法调用和一个方法主体关联起来被称作绑定。若在程序执行前进行绑定，叫做前期绑定，它是面向过程语言的默认绑定方式。在运行时根据对象的类型进行绑定叫做后期绑定，也叫动态绑定或运行时绑定。Java中除了static方法和final方法（private方法属于final方法）之外，其他所有方法都是后期绑定。</p><p>一旦知道Java中所有方法都是通过动态绑定实现多态这个事实后，我们就可以编写只与父类打交道的代码了，并且这些代码对所有子类都可以正确运行。例如上面的代码中，tune()方法里的i.play()，看起来是调用Instrument的play方法，实际运行时却是调用了Wind的play方法，正时由于动态绑定（多态），才产生了正确的行为。</p><p><strong>可扩展性：</strong>由于多态机制，我们可以根据需要添加任意多的继承自Instrument的新类型，而不需要更改tune方法，所有的新类型都能与原有类型一起正确运行。</p><p><strong>缺陷：“覆盖”私有方法。</strong>下面写法并不会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateOverride</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;private f()&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        PrivateOverride po = <span class="hljs-keyword">new</span> Derived();<br>        po.f();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PrivateOverride</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;public f()&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* output:</span><br><span class="hljs-comment">private f()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>我们所期望的输出是public f()，但是由于private方法被自动认为是final方法，而且对于子类是屏蔽的，因此，在这种请况下，Derived类中的f()方法就是一个全新的方法。既然父类的f()方法在子类Derived中不可见，因此甚至不能被重载。结论是：只有非private方法才可以被覆盖。</p><p><strong>缺陷：域与静态方法。</strong>域与静态方法不是多态的。只有普通方法是多态的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Super</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> field = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getField</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> field;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Super</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> field = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getField</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> field;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSuperField</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.field;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldAccess</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Super sup = <span class="hljs-keyword">new</span> Sub();  <span class="hljs-comment">//upcasting</span><br>        System.out.println(<span class="hljs-string">&quot;sup.field = &quot;</span> + sup.field + <span class="hljs-string">&quot;, sup.getField() = &quot;</span> + sup.getField());<br>        Sub sub = <span class="hljs-keyword">new</span> Sub();<br>        System.out.println(<span class="hljs-string">&quot;sub.field = &quot;</span> + sub.field + <span class="hljs-string">&quot;, sub.getField() = &quot;</span> + sub.getField() + <span class="hljs-string">&quot;, sub.getSuperField() = &quot;</span> + sub.getSuperField());<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* output:</span><br><span class="hljs-comment">sup.field = 0, sup.getField() = 1  //域field是父类的域，方法getField是子类的方法，说明域不是多态的</span><br><span class="hljs-comment">sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="3、构造器与多态"><a href="#3、构造器与多态" class="headerlink" title="3、构造器与多态"></a>3、构造器与多态</h3><p>在构造器内部调用一个动态绑定的方法会出现意想不到的情况，在构造器内唯一能安全调用的是父类中的final方法。</p><p>向上转型是安全的，但会丢失一些信息。向下转型是不安全的，需要做类型转换。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识——复用类</title>
    <link href="/2019/09/30/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%A4%8D%E7%94%A8%E7%B1%BB/"/>
    <url>/2019/09/30/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="1、组合语法"><a href="#1、组合语法" class="headerlink" title="1、组合语法"></a>1、组合语法</h3><p>组合，只需将对象引用置于新类即可。</p><h3 id="2、继承语法"><a href="#2、继承语法" class="headerlink" title="2、继承语法"></a>2、继承语法</h3><p>继承是所有OOP语言和Java中不可缺少的一部分。当创建一个类时，总是在继承，除非已明确指出要从其他类中继承，否则就是隐式地从Java的标准根类Object进行继承。</p><p>继承的关键字是extends，例：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>&#123;<span class="hljs-comment">/* class body */</span>&#125;<br></code></pre></td></tr></table></figure><p>子类（A）会自动获得父类（B）的所有域和方法。</p><p>其实继承就是创建一个新类，它包含一个父类的对象（隐式的）。可以在子类使用关键字<strong>super</strong>来引用父类对象。</p><span id="more"></span><p>对父类对象的初始化也是至关重要的，方法是在构造器中调用父类构造器来执行初始化，Java会自动在子类的构造器中插入对父类构造器的调用。但是，如果没有默认的父类构造器，或者想调用一个带参数的父类构造器，就必须用super关键字显式的编写调用父类构造器的语句，并且配以适当的参数列表。</p><h3 id="3、代理"><a href="#3、代理" class="headerlink" title="3、代理"></a>3、代理</h3><p>代理是组合与继承之间的中庸之道，因为我们将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该成员对象的所有方法（就像继承）。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpaceShipControllers</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">right</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpaceShipDelegation</span></span>&#123;<br><span class="hljs-keyword">private</span> SpaceShipControllers controllers = <span class="hljs-keyword">new</span> SpaceShipControllers();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>controllers.up(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>controllers.down(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>controllers.left(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">right</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>controllers.right(i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、向上转型"><a href="#4、向上转型" class="headerlink" title="4、向上转型"></a>4、向上转型</h3><p>假设有一个称为Instrument的代表乐器的父类和一个称为Wind的子类，把Wind引用转换为Instrument引用就是向上转型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Wind flute = <span class="hljs-keyword">new</span> Wind();<br>Instrument i = flute;    <span class="hljs-comment">//Upcasting</span><br></code></pre></td></tr></table></figure><h3 id="5、final关键字"><a href="#5、final关键字" class="headerlink" title="5、final关键字"></a>5、final关键字</h3><p>final关键字指的是“这是无法改变的”。</p><p>final数据，说明该数据是恒定不变的。当对象引用使用final时，它不能再指向另一个对象，但对象其自身可以被修改。根据惯例，既是static又是final的域将用大写表示，并用下划线分割每个单词。</p><p>空白final，即被声明为final但又未给定初值的域，空白final在使用前必须被初始化。空白final可以使一个类中的final域根据对象而有所不同，却又保持其恒定不变的特性。</p><p>final参数，java允许在参数列表以声明的方式将参数指明为final，这意味着你无法在方法中更改参数引用所执向的对象。</p><p>final方法，把方法锁定，以防任何继承类修改它的含义，即不会被覆盖。类中的所有private方法都隐式地指定为final的。</p><p>final类，说明该类不能被继承。final类的域可以根据个人意愿选择是或者不是final，但final类中所有的方法都隐式指定为final的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识——访问权限控制</title>
    <link href="/2019/09/30/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <url>/2019/09/30/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="1、包：库单元"><a href="#1、包：库单元" class="headerlink" title="1、包：库单元"></a>1、包：库单元</h3><p>包（package）内包含有一组类，它们在单一的名字空间之下被组织在一起。使用包就是为了区分相同名字的类。</p><p>如果一个类中没有声明一个包名，那么它就是在默认包里面。</p><p>一个.java文件里可以包含多个类，但只能有一个public类，并且该类的类名和文件名相同。编译的时候每个类都会生成一个.class文件。</p><span id="more"></span><h3 id="2、Java访问权限修饰词"><a href="#2、Java访问权限修饰词" class="headerlink" title="2、Java访问权限修饰词"></a>2、Java访问权限修饰词</h3><p>（1）包访问权限</p><p>没有使用访问权限修饰词，即默认包访问权限，对同一个包内的都可以访问，对包外的却是private。</p><p>（2）public</p><p>所有人都可以使用。</p><p>（3）private</p><p>只有在该类内可以访问，其他类都不可以访问。</p><p>（4）protected</p><p>​    该类的子类可以访问，同时还具有包访问权限（！！！）。</p><h3 id="3、类的访问权限"><a href="#3、类的访问权限" class="headerlink" title="3、类的访问权限"></a>3、类的访问权限</h3><p>类只有两种访问权限，包访问权限和public。</p><p>一个简单的设计模式，singleton（单例）模式，例：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;     <span class="hljs-comment">//核心思想：构造器私有化</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> singleton;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识——初始化与清理</title>
    <link href="/2019/09/25/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"/>
    <url>/2019/09/25/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1、用构造器确保初始化"><a href="#1、用构造器确保初始化" class="headerlink" title="1、用构造器确保初始化"></a>1、用构造器确保初始化</h1><p>​        在Java中，通过类构造器，确保每个类都会得到初始化。构造器采用与类相同的名称。</p><p>​        不接受任何参数的构造器叫默认构造器，术语无参构造器。如果你的类里没有构造器，编译器会自动创建一个默认构造器，如果你的类里有构造器（不管是有参还是无参），则编译器不会自动创建默认编译器。</p><p>​        构造器不返回任何东西，这和返回值为空（void）不同，空返回值可以有return语句。</p><span id="more"></span><h1 id="2、方法重载"><a href="#2、方法重载" class="headerlink" title="2、方法重载"></a>2、方法重载</h1><p>​        方法重载就是几个方法拥有相同的名字，但是参数类型或参数个数或参数顺序不同。</p><p>​        一个类的构造器也可以拥有多个，这也是方法重载。</p><p>​        基本类型能从一个较小的类型自动提升到一个较大的类型（例：short &gt;&gt; int &gt;&gt; long），这样可能会在重载时造成混淆。</p><p>​        不能以返回值区分重载方法，因为有时我们并不关心一个方法的返回值。例：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>f1();<span class="hljs-comment">//此时编译器不知道调用哪个</span><br></code></pre></td></tr></table></figure><h1 id="3、this关键字"><a href="#3、this关键字" class="headerlink" title="3、this关键字"></a>3、<strong>this</strong>关键字</h1><p>​        this关键字只能在方法内使用，表示对“调用方法的那个对象”的引用。this的用法和其他的对象引用相同。</p><p>​    在构造器中使用构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br><span class="hljs-keyword">int</span> i;<br>A()&#123;<br><span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);<br>&#125;<br>A(<span class="hljs-keyword">int</span> i)&#123;<br><span class="hljs-keyword">this</span>.i = i;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        只可以在构造器里用this调用一个构造器，而且不能在其他方法中调用构造器。</p><p>​        static方法就是没有this的方法，在static方法内不能调用非静态方法（反过来倒是可以）。</p><h1 id="4、清理：终结处理和垃圾回收"><a href="#4、清理：终结处理和垃圾回收" class="headerlink" title="4、清理：终结处理和垃圾回收"></a>4、清理：终结处理和垃圾回收</h1><p>​        一个对象如果失去用处，它就会被垃圾回收器回收掉，一个类的finalize方法会在对象回收前被调用，因此可以用finalize方法在垃圾回收时做一些清理工作。但是，垃圾回收不一定会发生，所以不能指望finalize()一定会被调用。更不要直接调用finalize()，这样并不能清理掉一个对象。一旦垃圾回收器准备好释放对象占用的空间，将首先调用finalize方法，并且在下一次垃圾回收动作发生时才真正回收对象占用的内存。</p><h1 id="5、构造器初始化"><a href="#5、构造器初始化" class="headerlink" title="5、构造器初始化"></a>5、构造器初始化</h1><p>​        初始化顺序：在类的内部，变量定义的先后顺序决定了初始化的顺序，即使变量定义散布于在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。并且，静态对象的初始化会先于非静态对象。静态初始化动作只进行一次。</p><p>​        静态初始化子句，例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Spoon</span></span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">static</span> String s;<br><span class="hljs-keyword">static</span> &#123;<br>i = <span class="hljs-number">47</span>;<br>s = <span class="hljs-string">&quot;aaa&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        实例初始化，和静态初始化一样，只不过少了static关键字。</p><h1 id="6、数组初始化"><a href="#6、数组初始化" class="headerlink" title="6、数组初始化"></a>6、数组初始化</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//两种定义方式</span><br><span class="hljs-keyword">int</span>[] a1;   <span class="hljs-comment">//推荐这种</span><br><span class="hljs-keyword">int</span> a2[];<br><span class="hljs-comment">//初始化方式</span><br>a1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];<br>a2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span>[] a3 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>​        可变参数列表，例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//两种方法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(Object[] args)</span></span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(Object... args)</span></span>&#123;...&#125;<span class="hljs-comment">//这种简便一点</span><br>f1(<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> Float(<span class="hljs-number">1.1</span>), <span class="hljs-keyword">new</span> Double(<span class="hljs-number">11.11</span>)&#125;);<br>f2(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> Float(<span class="hljs-number">1.1</span>), <span class="hljs-keyword">new</span> Double(<span class="hljs-number">11.11</span>));<br>f2();       <span class="hljs-comment">//参数可以为空，f1()不行</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识——操作符</title>
    <link href="/2019/09/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <url>/2019/09/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>++i先递增后取值，i++先取值后递增.</p><p>对象的等价值，例：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java">Integer n1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">47</span>);<br>Integer n2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">47</span>);<br>n1 == n2; <span class="hljs-comment">//false</span><br>n1.equals(n2); <span class="hljs-comment">//true</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>&#125;<br>Value v1 = <span class="hljs-keyword">new</span> Value();<br>Value v2 = <span class="hljs-keyword">new</span> Value();<br>v1.i = v2.i = <span class="hljs-number">100</span>;<br>v1.equals(v2); <span class="hljs-comment">//false，自己创建的类会这样，除非覆盖equals方法</span><br></code></pre></td></tr></table></figure><span id="more"></span><p>移位操作符： i &lt;&lt; j ，将i向左移j位，地位补0； i &gt;&gt; j ，将i向右移j位，&gt;&gt;是有符号右移操作符，当i的符号为正，高位补0，符号为负，高位补1。 i &gt;&gt;&gt; j,  无符号右移操作符，无论正负，高位补0。</p><p>三元操作符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span>-exp ? value1 : value2<br></code></pre></td></tr></table></figure><p>如果boolean-exp（布尔表达式）的结果为true，就计算value1，这个计算结果也是操作符的最终产生的值。false就计算value2。</p><p>类型转换：将一种数据类型转换为另一种。例:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">float</span> i = <span class="hljs-number">0.5f</span>;<br><span class="hljs-built_in">int</span> j = (<span class="hljs-built_in">int</span>) i;  <span class="hljs-comment">// j=0</span><br></code></pre></td></tr></table></figure><p>需要注意，浮点值转换为整型会直接把小数点后面的部分去掉。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[转载] Java import单类引入与包引入的区别</title>
    <link href="/2019/09/17/Java%20import%E5%8D%95%E7%B1%BB%E5%BC%95%E5%85%A5%E4%B8%8E%E5%8C%85%E5%BC%95%E5%85%A5%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/09/17/Java%20import%E5%8D%95%E7%B1%BB%E5%BC%95%E5%85%A5%E4%B8%8E%E5%8C%85%E5%BC%95%E5%85%A5%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>​        单类型导入（single-type-import），例如import java.io.File；</p><p>　　按需类型导入（type-import-on-demand），例如 import java.io.*；</p><p>　　关于这两种导入类型大家各有所爱，众说纷纭。这里分析一下这两种导入类型的大致工作原理供大家参考。</p><p>　　单类型导入比较好理解，仅仅导入一个public类或者接口。而对于按需类型导入，有人误解为导入一个包下的所有类，其实不然，看名字就知道，他只会按需导入，也就是说它并非导入整个包，而仅仅导入当前类需要使用的类。</p><span id="more"></span><p>　　既然如此是不是就可以放心的使用按需类型导入呢？非也，非也。因为单类型导入和按需类型导入对类文件的定位算法是不一样的。</p><p>　　java编译器会从启动目录（bootstrap），扩展目录（extension）和用户类路径下去定位需要导入的类，而这些目录仅仅是给出了类的顶层目录。编译器的类文件定位方法大致可以理解为如下公式：</p><p>　　顶层路径名 \ 包名 \ 文件名。class = 绝对路径</p><p>　　对于单类型导入很简单，因为包明和文件名都已经确定，所以可以一次性查找定位。</p><p>　　对于按需类型导入则比较复杂，编译器会把包名和文件名进行排列组合，然后对所有的可能性进行类文件查找定位。例如：</p><p>　　package com；</p><p>　　import java.io.*；</p><p>　　import java.util.*；</p><p>　　当你的类文件中用到了File类，那么可能出现File类的地方如下：</p><p>　　1、File \ File类属于无名包，就是说File类没有package语句，编译器会首先搜索无名包</p><p>　　2、com.File \ File类属于当前包</p><p>　　3、java.lang.File \编译器会自动导入java.lang包</p><p>　　4、java.io.File</p><p>　　5、java.util.File</p><p>　　需要注意的地方就是，编译器找到java.io.File类之后并不会停止下一步的寻找，而要把所有的可能性都查找完以确定是否有类导入冲突。假设此时的顶层路径有三个，那么编译器就会进行3*5=15次查找。</p><p>　　了解以上原理之后，我们可以得出这样的结论：按需类型导入是绝对不会降低<a href="http://java.chinaitlab.com/">Java</a>代码的执行效率的，但会影响到<a href="http://java.chinaitlab.com/">Java</a>代码的编译速度。</p><p>　　查看JDK的源代码就知道SUN的软件工程师一般不会使用按需类型导入。因为使用单类型导入至少有以下两点好处：</p><p>　　1.提高编译速度。</p><p>　　2.避免命名冲突。（例如：当你import java.awt.*；import java.util.*后，使用List的时候编译器将会出编译错误）</p><p>　　当然，使用单类型导入会使用你的import语句看起来很长。</p><p>本文转载自<a href="http://blog.sina.com.cn/s/blog_72e97ddb0102vvnt.html">http://blog.sina.com.cn/s/blog_72e97ddb0102vvnt.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识--一切都是对象</title>
    <link href="/2019/09/16/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/"/>
    <url>/2019/09/16/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-用引用操作对象"><a href="#1-用引用操作对象" class="headerlink" title="1 用引用操作对象"></a>1 用引用操作对象</h2><p>Java使用<strong>引用（reference）</strong>来操作对象，就像使用遥控器（引用）来操作电视机（对象）。例如：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">String  s</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></td></tr></table></figure><p>s是引用，“abc ”是对象。当然引用也可以独立存在，不一定需要一个对象与之关联。如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> s；<br></code></pre></td></tr></table></figure><p>如果这时向s发送一个消息，就会返回一个运行时错误。因为s实际没有与对象关联。因此，一种安全的做法是创建一个引用的同时进行初始化。</p><span id="more"></span><h2 id="2-必须由你创建所有对象"><a href="#2-必须由你创建所有对象" class="headerlink" title="2 必须由你创建所有对象"></a>2 必须由你创建所有对象</h2><p>一旦创建一个引用，就希望它能与一个新的对象相关联，通常用new操作符实现这一目的，new关键字的意思是“给我一个新对象”。例如</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure><p>对象的引用存储在堆栈里，而对象存储在堆里。</p><p>基本类型也是存储在堆栈里的。</p><table><thead><tr><th>基本类型</th><th>大小</th><th>包装器类型</th></tr></thead><tbody><tr><td>boolean</td><td>-</td><td>Boolean</td></tr><tr><td>char</td><td>16 bits</td><td>Character</td></tr><tr><td>byte</td><td>8 bits</td><td>Byte</td></tr><tr><td>short</td><td>16 bits</td><td>Short</td></tr><tr><td>int</td><td>32 bits</td><td>Integer</td></tr><tr><td>long</td><td>64 bits</td><td>Long</td></tr><tr><td>float</td><td>32 bits</td><td>Float</td></tr><tr><td>double</td><td>64 bits</td><td>Double</td></tr><tr><td>void</td><td>-</td><td>Void</td></tr></tbody></table><p>Java提供2个高精度计算的类：BigInteger和BigDecimal，它们大体上属于包装类，但没有对应的基本类型。BigInteger支持任意精度的整数，BigDecimal支持任意精度的定点数。</p><h2 id="3-永远不要销毁对象"><a href="#3-永远不要销毁对象" class="headerlink" title="3 永远不要销毁对象"></a>3 永远不要销毁对象</h2><p>大多数过程型语言都有作用域（scope）的概念，作用域决定了在其内定义的变量名的可见性与生命周期，在C、C++、Java中，作用域由花括号的位置决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在作用域1内只有x有效，在作用域2内x和y都有效，y只在作用域2内有效</span><br>&#123; <span class="hljs-comment">//start of scope 1</span><br><span class="hljs-keyword">int</span> x = <span class="hljs-number">12</span>;<br>&#123; <span class="hljs-comment">//start of scope 2</span><br><span class="hljs-keyword">int</span> y = <span class="hljs-number">13</span>;<br>&#125;  <span class="hljs-comment">//end of scope 2</span><br>&#125; <span class="hljs-comment">//end of scope 1</span><br></code></pre></td></tr></table></figure><p>尽管以下代码在C和C++中是合法的，但在Java中却不能这样写。因为C和C++允许将一个较大作用域的变量隐藏起来，而Java不允许。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">12</span>;<br>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">13</span>;  <span class="hljs-comment">//Illegal</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java对象不具备和基本类型一样的生命周期。当用new创建一个对象时，它可以存活于作用域之外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>引用s在作用域终点就消失了，然而s指向的对象仍然占据内存空间，直到该对象被垃圾回收器回收掉。</p><h2 id="4-创建新的数据类型：类"><a href="#4-创建新的数据类型：类" class="headerlink" title="4 创建新的数据类型：类"></a>4 创建新的数据类型：类</h2><p>Java使用<strong>class</strong>关键字定义一个新的类型，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ATypeName</span></span>&#123; <br><span class="hljs-comment">// class body goes here</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类里可以有两种类型的元素：<strong>字段</strong>（数据成员）和<strong>方法</strong>（成员函数）。</p><p>字段可以是任何类型的对象或者基本类型。</p><p>每个对象都有用来存储其字段的空间，普通字段不能在对象间共享（用static定义的字段可以）。</p><p>若类的某个成员是基本类型，即使没有进行初始化，java也会确保它获得一个默认值。</p><table><thead><tr><th>基本类型</th><th>默认值</th></tr></thead><tbody><tr><td>boolean</td><td>false</td></tr><tr><td>char</td><td>‘\u0000’  (null)</td></tr><tr><td>byte</td><td>(byte) 0</td></tr><tr><td>short</td><td>(short) 0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr></tbody></table><p>这些默认值对你的程序来说可能是不正确的，最好明确的对变量进行初始化。</p><p>然而上述初始化不适用于局部变量（即并非某个类的字段）。比如在某个方法中定义 int i，那么变量i可能是任意值，而不会初始化为0。</p><h2 id="5-方法、参数和返回值"><a href="#5-方法、参数和返回值" class="headerlink" title="5 方法、参数和返回值"></a>5 方法、参数和返回值</h2><p>Java的方法决定一个对象能接收什么样的消息，方法的基本组成部分包括：名称、参数、返回值和方法体，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ReturnType <span class="hljs-title">methodName</span><span class="hljs-params">(<span class="hljs-comment">/* Argument list */</span>)</span></span>&#123;<br><span class="hljs-comment">// method body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法的返回值的类型必须和返回类型（ReturnType）一致。参数列表给出了要传给方法的信息的类型和名称。参数列表所传递的实际是对象的引用（基本类型除外）。方法名和参数列表唯一地标识某个方法。</p><h2 id="6-构建一个Java程序"><a href="#6-构建一个Java程序" class="headerlink" title="6 构建一个Java程序"></a>6 构建一个Java程序</h2><p>名字空间，即包名，包名加类名是一个类的唯一标识符，以防止和其他相同名字的类发生冲突。</p><p>使用<strong>import</strong>关键字来导入你想要的类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;  <span class="hljs-comment">//单类型导入</span><br><span class="hljs-keyword">import</span> java.util.*;  <span class="hljs-comment">//按需类型导入</span><br></code></pre></td></tr></table></figure><p>单类型导入与按需类型导入的区别请看另一篇博文<a href="/2019/09/17/Java%20import%E5%8D%95%E7%B1%BB%E5%BC%95%E5%85%A5%E4%B8%8E%E5%8C%85%E5%BC%95%E5%85%A5%E7%9A%84%E5%8C%BA%E5%88%AB/">《Java import单类引入与包引入的区别》</a>,实际编程中更推荐使用单类型导入。</p><p><strong>static</strong>关键字</p><p>当声明一个事物是static时，就意味着这个域或者方法不会与包含它的那个类的任何对象实例关联在一起，即可以直接通过一个类来访问它的static域和static方法（当然也可以通过对象访问），例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 以下两种方法访问静态的x都是可以的</span><br><span class="hljs-keyword">int</span> i = A.x;<br>A a = <span class="hljs-keyword">new</span> A();<br><span class="hljs-keyword">int</span> j = a.x;<br></code></pre></td></tr></table></figure><h2 id="7-你的第一个Java程序"><a href="#7-你的第一个Java程序" class="headerlink" title="7 你的第一个Java程序"></a>7 你的第一个Java程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(Strng[] args)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>java.lang这个类库是默认导入到每个java文件中的。System类就是这个类库里的，所以使用它不需要导入，out是System的一个静态对象，所以可以直接通过类名引用。</p><p>一个java文件可以包含一个或多个类，但必须有一个类的类名和文件名相同。</p><p>main方法是程序的入口，但并不是每个类都有main方法。main方法的参数args是一个字符串数组，作用是从命令行接收参数，它是必须的，即使在很多时候都没有用到。</p><h2 id="8-注释和嵌入式文档"><a href="#8-注释和嵌入式文档" class="headerlink" title="8 注释和嵌入式文档"></a>8 注释和嵌入式文档</h2><p>Java有两种注释风格：多行注释与单行注释。</p><p>多行注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* This is a comment that</span><br><span class="hljs-comment">  continues across lines */</span><br></code></pre></td></tr></table></figure><p>实际很多人习惯这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* This is a comment that</span><br><span class="hljs-comment"> * continues across lines</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>单行注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// this is a one-line comment</span><br></code></pre></td></tr></table></figure><p>javadoc是一个注释提取工具，它能把代码里的注释提取出来单独形成一个文档（实际输出的是一个html文件）。</p><p>javadoc命令只能在 “ /** ” 注释中出现，结束于 “ */ ” 。使用javadoc的方式主要有两种：嵌入html，或使用“文档标签”（以@开头的命令）。</p><p>javadoc只能为public和protected成员进行文档注释。</p><p>javadoc的具体使用可以看这篇文章<a href="https://blog.csdn.net/vbirdbest/article/details/80296136">https://blog.csdn.net/vbirdbest/article/details/80296136</a></p><h2 id="9-编码风格"><a href="#9-编码风格" class="headerlink" title="9 编码风格"></a>9 编码风格</h2><p>使用驼峰风格，类名每个单词首字母大写，其他内容（变量，方法名，对象引用）第一个单词首字母小写，例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllTheColorOfTheRainbow</span></span>&#123;<br><span class="hljs-keyword">int</span> anIntegerRepresentingColors;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">changeTheHueOfTheColor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newHue)</span></span>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识——对象导论</title>
    <link href="/2019/09/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/"/>
    <url>/2019/09/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p> 最近在导师的要求下开始加强Java基础，所以找了本《Thinking in Java》(Java编程思想)来看看，顺便做点笔记来证明自己看过，所以《Java基础知识》系列博客都是这本书的读书笔记。</p><span id="more"></span><h2 id="1-抽象过程"><a href="#1-抽象过程" class="headerlink" title="1 抽象过程"></a>1 抽象过程</h2><p>汇编语言是对底层机器的轻微抽象，命令式语言（如C语言）是对汇编语言的抽象。</p><p>程序员必须建立起在机器模型（位于“解空间”内，这是对问题建模的地方，如计算机）和实际问题的模型（位于“问题空间”内，这是问题存在的地方，如一项业务）之间的关联。<br><strong>面向对象</strong>方式把问题空间中的元素抽象为对象，程序可以通过添加新类型的对象使自身适应于某个特定问题，当我们在阅读描述解决方案的代码时，也是在阅读问题的描述。</p><p>面向对象语言的五个特性：</p><p>1）万物皆对象。</p><p>2）程序是对象的集合，它们通过发送消息来告知彼此所要做的。</p><p>3）每个对象都有自己的由其他对象所构成的存储。</p><p>4）每个对象都有其类型。即每个对象都是某个<strong>类</strong>（class）的一个<strong>实例</strong>（instance）。</p><p>5）某一特定类型的所有对象都可以接收同样的消息。</p><h2 id="2-每个对象都有一个接口"><a href="#2-每个对象都有一个接口" class="headerlink" title="2 每个对象都有一个接口"></a>2 每个对象都有一个接口</h2><p><img src="/2019/09/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1568643825401.png"></p><p><strong>接口</strong>确定了对某一特定对象所能发出的请求。但是，在程序中必须有满足这些请求的代码，这些代码和隐藏的数据一起构成了<strong>实现</strong>。</p><h2 id="3-每个对象都提供服务"><a href="#3-每个对象都提供服务" class="headerlink" title="3 每个对象都提供服务"></a>3 每个对象都提供服务</h2><p>程序本身向用户提供服务，它将通过调用其他对象提供的服务来实现这一目的。</p><p>在良好的面向对象设计中，每个对象都可以很好的完成一项任务，但它并不试图做更多的事。</p><h2 id="4-被隐藏的具体实现"><a href="#4-被隐藏的具体实现" class="headerlink" title="4 被隐藏的具体实现"></a>4 被隐藏的具体实现</h2><p>将程序开发人员按角色分为<strong>类创建者</strong>和<strong>客户端程序员</strong>（就好比一个类库的创建者和它的使用者）是大有裨益的。类创建者的目标是构建类，这种类只向客户端程序员暴露必须的部分（例如接口），而隐藏其他部分（例如实现）。这意味着类创建者可以任意修改被隐藏的部分，而不用担心对其他任何人造成影响。</p><p>访问控制的第一个存在原因是让客户端程序员无法触及他们不应该触及的部分，第二个原因是允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。</p><p>Java用三个关键字控制访问：<strong>public</strong>，<strong>private</strong>，<strong>protected</strong>。public表示紧随其后的元素对任何人都是可用的，而private表示除类型创建者和类型内部方法之外的任何人都不能访问，protected与private的作用相当，差别在于继承的类可以访问protected成员，却不能访问private成员。</p><h2 id="5-复用具体实现"><a href="#5-复用具体实现" class="headerlink" title="5 复用具体实现"></a>5 复用具体实现</h2><p>最简单的复用某个类的方式就是直接使用该类的一个对象，此外也可以把那个类的一个对象置于某个新的类中。新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。</p><p>因为是在使用现有的类新的类，所以这种概念被成为组合（competition），如果组合是动态发生的，那么它通常被称为聚合（aggregation）。</p><p>组合通常被视为“<strong>has-a</strong>”（拥有）关系，就像我们常说“汽车拥有一个引擎”。</p><p>组合带来了极大的灵活性，新类成员对象通常被声明为private，使得使用新类的客户端程序员不能访问它们，这也使得你可以在不干扰现有客户端代码的情况下，修改这些成员。也可以在运行时修改这些成员对象，以实现动态修改程序的行为。</p><h2 id="6-继承"><a href="#6-继承" class="headerlink" title="6 继承"></a>6 继承</h2><p>继承就是以现有类为基础，复制它，然后通过添加和修改这个副本来创建新类。</p><p>当源类（也被称为<strong>父类</strong>）发生变动时，被修改过的副本（被称为<strong>子类</strong>）也会反映出这些变动。</p><p>继承现有类型时，也就创造了新的类型。这个新的类型不仅包含现有类型的所有成员（尽管private成员被隐藏起来，并且不可访问），而且更重要的是它复制了父类的接口。也就是说，所有可以发送给父类对象的消息同时也可以发送给子类对象。</p><p>有两种方法可以使父类与子类产生差异。第一种方法是直接在子类中添加新的方法，这意味着父类不能直接满足你的需求，必须添加更多方法。第二种也是更重要的一种方法是在子类中改变父类方法的行为，这被称为<strong>覆盖</strong>（需要添加@override注解）。</p><p>假如继承只覆盖父类的方法，而并不添加在父类中没有的新方法，就意味着子类和父类时完全相同的类型，具有完全相同的接口，可以用一个子类对象来完全替代一个父类对象（被称为纯粹替代），我们经常将这种情况下子类与父类之间的关系称为<strong>is-a（是一个）</strong>关系。</p><p>有时必须在子类中添加新的接口元素，这个新类型仍可替代父类，但这种替代并不完美，因为基类无法访问新添加的方法。这种情况我们描述为<strong>is-like-a（像是一个）</strong>关系。</p><h2 id="7-伴随多态的可互换对象"><a href="#7-伴随多态的可互换对象" class="headerlink" title="7 伴随多态的可互换对象"></a>7 伴随多态的可互换对象</h2><p><img src="/2019/09/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1569130247016.png"></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(Shape shape)</span></span>&#123;<br>shape.erase();<br>    shape.draw();<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法可以与任何Shape对话，如果在其他地方调用了doSomething()方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Circle circle = <span class="hljs-keyword">new</span> Circle();<br>Square square = <span class="hljs-keyword">new</span> Square();<br>Triangle triangle = <span class="hljs-keyword">new</span> Triangle();<br>doSomething(circle);<br>doSomething(square);<br>doSomething(triangle);<br></code></pre></td></tr></table></figure><p>对doSomething()方法的调用都会正确的执行，而不管对象的确切类型。</p><p>把子类看做它的父类的过程称为<strong>向上转型（upcasting）</strong>。</p><h2 id="8-单根继承结构"><a href="#8-单根继承结构" class="headerlink" title="8 单根继承结构"></a>8 单根继承结构</h2><p>在Java中，所有的类最终都继承自单一的父类（<strong>Object</strong>类）。</p><p>单根继承结构使垃圾回收器的实现变得容易许多，而垃圾回收器是Java相对C++的重要改进之一（Java是基于C++的）。</p><h2 id="9-容器"><a href="#9-容器" class="headerlink" title="9 容器"></a>9 容器</h2><p>创建一种新的对象类型，这种新的对象类型持有其他对象的引用（或者使用数组类型来实现这一功能），这种新的类型被称为容器。</p><p>Java在其标准类库中包含了大量的容器，例如List（用于存储序列），Map（关联数组，用来建立对象之间的关联），Set（每种类型的对象只持有一个）。以及诸如队列、树、堆栈等更多的构件。</p><p>Java拥有多种类型的容器的原因有两个，第一，不同容器提供不同类型的接口和外部行为；第二，不同容器对于某些操作具有不同的效率。</p><h2 id="10-对象的创建和生命期"><a href="#10-对象的创建和生命期" class="headerlink" title="10 对象的创建和生命期"></a>10 对象的创建和生命期</h2><p>每个对象为了生存都需要资源，尤其是内存，当我们不需要一个对象时，它必须被清理掉，使其占用的资源可以被释放掉和重用。</p><p>Java完全使用动态内存分配方式（在被称为堆（heap）的内存池中动态的创建对象）。每当想要创建一个新的对象时，就要使用new关键字来构建此对象的动态实例。</p><p>java使用垃圾回收器来处理内存释放问题，垃圾回收器知道对象何时不再被使用，并自动释放对象占用的内存。</p><h2 id="11-异常处理：处理错误"><a href="#11-异常处理：处理错误" class="headerlink" title="11 异常处理：处理错误"></a>11 异常处理：处理错误</h2><p>异常是一种对象，它在出错地点被抛出，并被专门设计用来处理特定类型错误的相应的异常处理器捕获。</p><p>异常处理就像是与程序正常执行路径并行的、在错误发生时执行另一条路径。</p><p>异常提供了一种从错误状况进行可靠恢复的途径，现在不再是只能退出程序，你可以经常进行校正，并恢复程序的执行，这些都有助于编写出更健壮的程序。</p><p>如果没有编写正确的异常处理代码，那么就会得到一条编译时的出错信息。</p><h2 id="12-并发编程"><a href="#12-并发编程" class="headerlink" title="12 并发编程"></a>12 并发编程</h2><p>把问题切分为多个可独立运行的部分（任务），从而提高程序的响应能力，这些彼此独立运行的部分称之为<strong>线程</strong>，上述概念被称为<strong>并发</strong>。</p><p>多个并行任务使用一个共享资源的过程是：某个任务锁定某项资源，完成其任务，然后释放资源锁，使其他任务可以使用这项资源。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/09/01/hello-world/"/>
    <url>/2019/09/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
